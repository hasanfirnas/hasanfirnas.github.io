function main(workbook: ExcelScript.Workbook) {

  const SOURCE_SHEET = "Sheet1";
  const SOURCE_TABLE = "OfficeForms.Table";
  const BIN_SHEET = "Bin";
  const BIN_TABLE = "Bin.Table";

  const sourceTable = workbook.getWorksheet(SOURCE_SHEET).getTable(SOURCE_TABLE);
  const binTable = workbook.getWorksheet(BIN_SHEET).getTable(BIN_TABLE);

  const sourceHeaders = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const binHeaders = binTable.getHeaderRowRange().getValues()[0] as string[];

  const sourceRange = sourceTable.getRangeBetweenHeaderAndTotal();
  const sourceData = sourceRange.getValues() as (string | number | boolean)[][];

  // ------------------------
  // Find Id column
  // ------------------------
  const idColIndex = sourceHeaders.indexOf("Id");
  if (idColIndex === -1) {
    throw new Error("Id column not found in source table");
  }

  // ------------------------
  // Detect RITM column
  // ------------------------
  const ritmRegex = /^RITM\d{4,}$/i;
  let ritmColIndex = -1;
  let maxHits = 0;

  sourceHeaders.forEach((_, colIndex) => {
    let hits = 0;
    for (const row of sourceData) {
      const cell = row[colIndex];
      if (typeof cell === "string" && ritmRegex.test(cell.trim())) {
        hits++;
      }
    }
    if (hits > maxHits) {
      maxHits = hits;
      ritmColIndex = colIndex;
    }
  });

  if (ritmColIndex === -1) {
    throw new Error("RITM column not detected");
  }

  // ------------------------
  // Normalize RITM values
  // ------------------------
  for (let i = 0; i < sourceData.length; i++) {
    const val = sourceData[i][ritmColIndex];
    if (typeof val === "string") {
      sourceData[i][ritmColIndex] = val.trim();
    }
  }

  // ------------------------
  // Group by RITM
  // ------------------------
  type Entry = {
    row: (string | number | boolean)[];
    id: number;
  };

  const groups: Record<string, Entry[]> = {};

  for (const row of sourceData) {
    const ritmCell = row[ritmColIndex];
    const idCell = row[idColIndex];

    if (
      typeof ritmCell === "string" &&
      ritmRegex.test(ritmCell) &&
      typeof idCell !== "boolean" &&
      !isNaN(Number(idCell))
    ) {
      const key = ritmCell.toUpperCase();
      if (!groups[key]) groups[key] = [];
      groups[key].push({ row, id: Number(idCell) });
    }
  }

  const rowsToKeep: (string | number | boolean)[][] = [];
  const rowsToBin: (string | number | boolean)[][] = [];

  // ------------------------
  // Decide KEEP vs BIN
  // ------------------------
  for (const ritm in groups) {
    const entries = groups[ritm];

    if (entries.length === 1) {
      rowsToKeep.push(entries[0].row);
      continue;
    }

    entries.sort((a, b) => a.id - b.id);
    const keeper = entries[entries.length - 1];
    rowsToKeep.push(keeper.row);

    for (const e of entries) {
      if (e !== keeper) {
        rowsToBin.push(e.row);
      }
    }
  }

  // ------------------------
  // Move rows to Bin (column-safe mapping)
  // ------------------------
  for (const srcRow of rowsToBin) {
    const binRow: (string | number | boolean)[] = [];

    for (const binHeader of binHeaders) {
      const srcIndex = sourceHeaders.indexOf(binHeader);
      binRow.push(srcIndex !== -1 ? srcRow[srcIndex] : "");
    }

    binTable.addRow(-1, binRow);
  }

  // ------------------------
  // Clear source table contents
  // ------------------------
  if (sourceData.length > 0) {
    sourceRange.clear(ExcelScript.ClearApplyTo.contents);
  }

  // ------------------------
  // Rebuild source table
  // ------------------------
  for (const row of rowsToKeep) {
    sourceTable.addRow(-1, row);
  }
}
