function main(workbook: ExcelScript.Workbook) {
  const sourceTable = workbook.getWorksheet("Sheet1").getTable("OfficeForms.Table");
  const binTable = workbook.getWorksheet("Bin").getTable("Bin.Table");

  // 1. Get Data with explicit types
  const dataRange = sourceTable.getRangeBetweenHeaderAndTotal();
  // Define row values type to avoid "any"
  const data: (string | number | boolean)[][] = dataRange.getValues();
  const headers = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  
  const idColIndex = headers.indexOf("Id");
  const ritmRegex = /^RITM\d{4,}$/i;

  // 2. Detect RITM Column
  let ritmColIndex = -1;
  let maxCount = 0;
  headers.forEach((_, colIdx) => {
    let count = 0;
    for (let row of data) {
      if (ritmRegex.test(row[colIdx]?.toString().trim())) count++;
    }
    if (count > maxCount) {
      maxCount = count;
      ritmColIndex = colIdx;
    }
  });

  if (ritmColIndex === -1) return;

  // 3. Logic: Find Duplicates (Explicitly type the record)
  const ritmGroups: Record<string, { rowIndex: number, id: number, values: (string | number | boolean)[] }[]> = {};
  
  data.forEach((row, index) => {
    const ritm = row[ritmColIndex]?.toString().trim().toUpperCase();
    const id = Number(row[idColIndex]);
    if (ritm && !isNaN(id)) {
      if (!ritmGroups[ritm]) ritmGroups[ritm] = [];
      ritmGroups[ritm].push({ rowIndex: index, id, values: row });
    }
  });

  // Explicitly type the movement array
  let rowsToMove: (string | number | boolean)[][] = [];
  let indicesToDelete: number[] = [];

  for (const ritm in ritmGroups) {
    const entries = ritmGroups[ritm];
    if (entries.length <= 1) continue;

    // Sort by ID ascending
    entries.sort((a, b) => a.id - b.id);
    
    // The last one is the keeper, others move
    for (let i = 0; i < entries.length - 1; i++) {
      rowsToMove.push(entries[i].values);
      indicesToDelete.push(entries[i].rowIndex);
    }
  }

  // 4. PERFORM MOVEMENT
  if (rowsToMove.length > 0) {
    // Add all to Bin
    binTable.addRows(null, rowsToMove);

    // Delete from Source (Bottom-to-Top)
    indicesToDelete.sort((a, b) => b - a);
    indicesToDelete.forEach(index => {
      sourceTable.deleteRowsAt(index, 1);
    });
  }
}
