function main(workbook: ExcelScript.Workbook) {
  // ===== CONFIG =====
  const sourceSheetName = "Sheet1";
  const sourceTableName = "OfficeForms.Table";
  const destSheetName = "Bin";
  const destTableName = "Bin.Table";

  // IMPORTANT: set dryRun = true to only log what would happen.
  // Change to false only AFTER you validated the dry-run logs and/or tested on a copy.
  const dryRun = true;

  // ===== HELPERS =====
  function normalizeColor(raw: string | undefined | null): string {
    if (!raw) return "";
    let s = raw.toString().trim().toLowerCase();

    if (s.startsWith("rgb(")) {
      const nums = s
        .replace(/^rgb\(|\)$/g, "")
        .split(",")
        .map(x => Number(x.trim()));
      if (nums.length === 3 && nums.every(n => !isNaN(n))) {
        return (
          "#" +
          nums
            .map(n => {
              const h = n.toString(16);
              return h.length === 1 ? "0" + h : h;
            })
            .join("")
        );
      }
    }

    if (/^#?[0-9a-f]{6}$/.test(s)) {
      if (!s.startsWith("#")) s = "#" + s;
      return s;
    }

    if (/^#?[0-9a-f]{3}$/.test(s)) {
      if (!s.startsWith("#")) s = "#" + s;
      const r = s[1], g = s[2], b = s[3];
      return "#" + r + r + g + g + b + b;
    }

    if (s === "red") return "#ff0000";
    return "";
  }

  const canonicalRed = "#ff0000";

  // ===== GET TABLES & BASIC VALIDATION =====
  const srcSheet = workbook.getWorksheet(sourceSheetName);
  if (!srcSheet) throw new Error(`Source sheet "${sourceSheetName}" not found.`);
  const srcTable = srcSheet.getTable(sourceTableName);
  if (!srcTable) throw new Error(`Source table "${sourceTableName}" not found.`);

  const dstSheet = workbook.getWorksheet(destSheetName);
  if (!dstSheet) throw new Error(`Destination sheet "${destSheetName}" not found.`);
  const dstTable = dstSheet.getTable(destTableName);
  if (!dstTable) throw new Error(`Destination table "${destTableName}" not found.`);

  // Check column counts (must match for safe copy)
  const srcColCount = srcTable.getColumns().length;
  const dstColCount = dstTable.getColumns().length;
  if (srcColCount !== dstColCount) {
    throw new Error(`Column count mismatch: source has ${srcColCount}, destination has ${dstColCount}. Aborting.`);
  }

  // ===== SCAN: find rows to move (based on current table state) =====
  const rowsToMove: { index: number; fillColorRaw: string | null }[] = [];

  const srcBodyRange = srcTable.getRangeBetweenHeaderAndTotal();
  const srcRowCount = srcBodyRange.getRowCount();
  if (srcRowCount === 0) {
    console.log("Source table has no rows. Nothing to do.");
    return;
  }

  for (let i = 0; i < srcRowCount; i++) {
    const rowRange = srcBodyRange.getRow(i);
    const fmt = rowRange.getFormat();
    const isStruck = fmt.getFont().getStrikethrough();
    const fillColorRaw = fmt.getFill().getColor();
    const normalized = normalizeColor(fillColorRaw);
    const isRed = normalized === canonicalRed;

    if (isStruck && isRed) {
      rowsToMove.push({ index: i, fillColorRaw: fillColorRaw ?? "" });
    }
  }

  if (rowsToMove.length === 0) {
    console.log("No rows found that are exactly red + strikethrough. Nothing moved.");
    return;
  }

  console.log(`Found ${rowsToMove.length} row(s) to move (red + struck).`);
  rowsToMove.forEach(r => console.log(`  - row index (body): ${r.index}`));

  if (dryRun) {
    console.log("Dry run enabled. No changes applied. Set dryRun = false to perform the move.");
    return;
  }

  // ===== PERFORM MOVE: bottom->top to keep indices stable =====
  rowsToMove
    .sort((a, b) => b.index - a.index) // descending
    .forEach(item => {
      // re-obtain body range for accuracy after prior deletions
      const bodyRange = srcTable.getRangeBetweenHeaderAndTotal();
      const rowCountNow = bodyRange.getRowCount();
      if (item.index < 0 || item.index >= rowCountNow) {
        console.log(`Skipping row index ${item.index} â€” index out of range after prior changes.`);
        return;
      }

      const srcRowRange = bodyRange.getRow(item.index);
      const rowValues = srcRowRange.getValues()[0] as (string | number | boolean)[];

      // Append values to dest table
      dstTable.addRow(-1, rowValues);

      // Apply per-cell formatting to newly created destination row
      const dstBodyRange = dstTable.getRangeBetweenHeaderAndTotal();
      const dstRowIdx = dstBodyRange.getRowCount() - 1;
      const dstRowRange = dstBodyRange.getRow(dstRowIdx);

      // copy cell-by-cell formatting (fill + font properties)
      for (let c = 0; c < srcColCount; c++) {
        const sCell = srcRowRange.getCell(0, c);
        const dCell = dstRowRange.getCell(0, c);

        const sFmt = sCell.getFormat();
        const sFill = sFmt.getFill().getColor();
        const sFont = sFmt.getFont();
        const sFontColor = sFont.getColor();
        const sBold = sFont.getBold();
        const sItalic = sFont.getItalic();
        const sStrike = sFont.getStrikethrough();
        const sUnderline = sFont.getUnderline();

        if (sFill) dCell.getFormat().getFill().setColor(sFill);
        if (sFontColor) dCell.getFormat().getFont().setColor(sFontColor);
        dCell.getFormat().getFont().setBold(sBold);
        dCell.getFormat().getFont().setItalic(sItalic);
        dCell.getFormat().getFont().setStrikethrough(sStrike);
        if (sUnderline) dCell.getFormat().getFont().setUnderline(sUnderline);
      }

      // Now delete the source row
      srcTable.deleteRowsAt(item.index, 1);
      console.log(`Moved row (body index ${item.index}) to destination and deleted from source.`);
    });

  console.log(`Completed move of ${rowsToMove.length} row(s).`);
}
