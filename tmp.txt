function main(workbook: ExcelScript.Workbook) {
  const sourceSheet = workbook.getWorksheet("Sheet1");
  const sourceTable = sourceSheet.getTable("OfficeForms.Table");
  const binSheet = workbook.getWorksheet("Bin");
  const binTable = binSheet.getTable("Bin.Table");

  // 1. Get Data
  const dataRange = sourceTable.getRangeBetweenHeaderAndTotal();
  const data = dataRange.getValues();
  const headers = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  
  const idColIndex = headers.indexOf("Id");
  const ritmRegex = /^RITM\d{4,}$/i;

  // 2. Detect RITM Column (Dynamic)
  let ritmColIndex = -1;
  let maxCount = 0;
  headers.forEach((_, colIdx) => {
    let count = 0;
    for (let row of data) {
      if (ritmRegex.test(row[colIdx]?.toString().trim())) count++;
    }
    if (count > maxCount) {
      maxCount = count;
      ritmColIndex = colIdx;
    }
  });

  if (ritmColIndex === -1) return;

  // 3. Logic: Find Duplicates (Keep highest ID)
  const ritmGroups: Record<string, { rowIndex: number, id: number, values: any[] }[]> = {};
  
  data.forEach((row, index) => {
    const ritm = row[ritmColIndex]?.toString().trim().toUpperCase();
    const id = Number(row[idColIndex]);
    if (ritm && !isNaN(id)) {
      if (!ritmGroups[ritm]) ritmGroups[ritm] = [];
      ritmGroups[ritm].push({ rowIndex: index, id, values: row });
    }
  });

  let rowsToMove: any[][] = [];
  let indicesToDelete: number[] = [];

  for (const ritm in ritmGroups) {
    const entries = ritmGroups[ritm];
    if (entries.length <= 1) continue;

    // Sort by ID ascending
    entries.sort((a, b) => a.id - b.id);
    
    // The last one is the keeper (highest ID), all others move to Bin
    for (let i = 0; i < entries.length - 1; i++) {
      rowsToMove.push(entries[i].values);
      indicesToDelete.push(entries[i].rowIndex);
    }
  }

  // 4. PERFORM THE MOVEMENT (The Fast Way)
  if (rowsToMove.length > 0) {
    // A. Add all rows to Bin Table at once (Super Fast)
    binTable.addRows(null, rowsToMove);

    // B. Delete rows from Source Table
    // We sort indices descending to delete from bottom-to-top so the table doesn't shift
    indicesToDelete.sort((a, b) => b - a);
    indicesToDelete.forEach(index => {
      sourceTable.deleteRowsAt(index, 1);
    });

    console.log(`âœ… Successfully moved ${rowsToMove.length} duplicates to Bin.`);
  } else {
    console.log("No duplicates found.");
  }
}
