---

## ðŸ“§ Email Templates for Each Rejection Reason

| Script Output | Template Type | Message (with placeholders) |
|---------------|---------------|-----------------------------|
| **`pass:new`** | Allow | *No email â€“ continue flow.* |
| **`reject:Active`** | Detailed | **Subject:** Form Submission Rejected â€“ RITM Already in Review<br><br>**Body:**<br>Your form submission for RITM `{RITM}` has been rejected because this request is already **Active** and under review.<br><br>**Details of the existing submission:**<br>â€¢ Submitted by: `{SubmittedBy}`<br>â€¢ Submission ID: `{Id}`<br><br>Please wait until that submission is closed before resubmitting. If you believe the existing information is incorrect, please **set up a call with Hassan** immediately to resolve the issue. |
| **`reject:Closed Complete`** | Detailed | **Subject:** Form Submission Rejected â€“ RITM Already Closed<br><br>**Body:**<br>Your form submission for RITM `{RITM}` has been rejected because this request is already **Closed Complete**. A previous submission has been fully processed.<br><br>**Details of the completed submission:**<br>â€¢ Submitted by: `{SubmittedBy}`<br>â€¢ Submission ID: `{Id}`<br><br>If you need to update the PCI flag for this CI, please submit an **Update CI Request** via [Insert Link Here]. **Important:** Do **not** submit an update request if the CI is not operational â€“ wait until it is operational. |
| **`reject:Cancelled`** | Detailed | **Subject:** Form Submission Rejected â€“ RITM Cancelled<br><br>**Body:**<br>Your form submission for RITM `{RITM}` has been rejected because this RITM is marked as **Cancelled** in ServiceNow. Cancelled requests cannot be processed.<br><br>If you believe this is an error, please contact the ServiceNow administrator to verify the RITM status. |
| **`reject:Submitted Again`** | Simple | **Subject:** Form Submission Rejected â€“ Duplicate Attempt Detected<br><br>**Body:**<br>Your form submission for RITM `{RITM}` has been rejected because a previous submission was already made and marked as **Submitted Again**. This indicates that the request was already processed or rejected.<br><br>No further action is needed. If you have questions, please contact Hassan. |
| **`reject:Bin-Duplicate`** | Simple | **Subject:** Form Submission Rejected â€“ Duplicate Entry Detected<br><br>**Body:**<br>Your form submission for RITM `{RITM}` has been rejected because duplicate entries for this RITM were found. To maintain data integrity, we cannot accept another duplicate.<br><br>If you need to correct information, please update the original submission instead of creating a new one. For assistance, contact Hassan. |

---

Your form submission for RITM {RITM} has been rejected because a duplicate or previously processed entry was detected.

If you need assistance, please contact Hasan.


/**
 * Searches the output table for a given RITM and decides whether to allow a new submission.
 * Returns "pass:new" if allowed, otherwise "reject:<reason>".
 * @param workbook - The Excel workbook object.
 * @param ritmInput - The RITM ID to search for (user will be prompted).
 */

// ====================
// CONFIGURATION
// ====================
const OUTPUT_SHEET = "Output";
const OUTPUT_TABLE = "OuputTable";

function main(workbook: ExcelScript.Workbook, ritmInput: string): string {
  // Validate input
  if (!ritmInput || ritmInput.trim() === "") {
    console.log("Error: No RITM ID provided.");
    return "error:no_input";
  }
  const searchRitm: string = ritmInput.trim();

  // Get the output worksheet
  const sheet: ExcelScript.Worksheet = workbook.getWorksheet(OUTPUT_SHEET);
  if (!sheet) {
    console.log(`Error: Worksheet "${OUTPUT_SHEET}" not found.`);
    return `error:sheet_not_found`;
  }

  // Get the output table
  const table: ExcelScript.Table = sheet.getTable(OUTPUT_TABLE);
  if (!table) {
    console.log(`Error: Table "${OUTPUT_TABLE}" not found in sheet "${OUTPUT_SHEET}".`);
    return `error:table_not_found`;
  }

  // Get headers
  const headers: string[] = table.getHeaderRowRange().getValues()[0] as string[];

  // Find column indices
  const idColIndex: number = 0;                      // First column is Id
  const ritmColIndex: number = headers.findIndex(h => /^RITM/i.test(h));
  const cmdbStatusColIndex: number = headers.indexOf("CMDB Status");

  // Validate critical columns
  if (ritmColIndex === -1) {
    console.log("Error: No column with header starting with 'RITM' found.");
    return "error:ritm_column_missing";
  }
  if (cmdbStatusColIndex === -1) {
    console.log("Warning: 'CMDB Status' column not found; status will be shown as 'N/A'.");
  }

  // Get data range (rows below headers)
  const dataRange: ExcelScript.Range = table.getRangeBetweenHeaderAndTotal();
  const data: (string | number | boolean)[][] = dataRange.getValues() as (string | number | boolean)[][];

  // Collect all rows that match the input RITM
  interface Match {
    ritm: string;
    id: string;
    status: string;
  }
  const matches: Match[] = [];

  for (let i = 0; i < data.length; i++) {
    const row = data[i];
    const cellValue = row[ritmColIndex];
    if (!cellValue) continue;

    const ritmValue: string = cellValue.toString().trim();
    if (ritmValue.toLowerCase() === searchRitm.toLowerCase()) {
      const idValue: string = row[idColIndex] ? row[idColIndex].toString() : "";
      const statusValue: string = (cmdbStatusColIndex !== -1 && row[cmdbStatusColIndex])
        ? row[cmdbStatusColIndex].toString()
        : "N/A";
      matches.push({ ritm: ritmValue, id: idValue, status: statusValue });
    }
  }

  // If no matches, it's a new RITM
  if (matches.length === 0) {
    console.log("No existing entries found.");
    return "pass:new";
  }

  // Log all matches for inspection (these will appear in Power Automate logs)
  console.log(`Found ${matches.length} occurrence(s) of RITM ${searchRitm}:`);
  matches.forEach((match, index) => {
    console.log(`[${index + 1}] RITM: ${match.ritm}, Id: ${match.id}, CMDB Status: ${match.status}`);
  });

  // ====================
  // DECISION LOGIC
  // ====================
  // Define blocking statuses and their priority (higher number = higher priority)
  const blockingStatusPriority: { [key: string]: number } = {
    "Cancelled": 5,
    "Closed Complete": 4,
    "Active": 3,
    "Submitted Again": 2,
    "Bin-Duplicate": 1
  };

  let highestPriority = 0;
  let reason = "";

  for (const match of matches) {
    const status = match.status;
    const priority = blockingStatusPriority[status];
    if (priority !== undefined && priority > highestPriority) {
      highestPriority = priority;
      reason = status;
    }
  }

  // Return final decision
  if (highestPriority > 0) {
    return `reject:${reason}`;
  } else {
    return "pass:new";
  }
}
