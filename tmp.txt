function main(workbook: ExcelScript.Workbook) {

  const SOURCE_SHEET = "Bin";
  const SOURCE_TABLE = "Bin.Table";
  const ARCHIVE_TABLE = "Bin_Archive.Table"; // üëà change if needed

  const sourceTable = workbook.getWorksheet(SOURCE_SHEET).getTable(SOURCE_TABLE);
  const archiveTable = workbook.getTable(ARCHIVE_TABLE);

  const headers = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const dataRange = sourceTable.getRangeBetweenHeaderAndTotal();
  const data = dataRange.getValues();

  // ---- Find Id column ----
  const idColIndex = headers.indexOf("Id");
  if (idColIndex === -1) {
    throw new Error("Couldn't find 'Id' column");
  }

  // ---- Detect RITM column ----
  const ritmRegex = /^RITM\d{4,}$/i;
  let ritmColIndex = -1;
  let maxCount = 0;

  headers.forEach((_, colIndex) => {
    let count = 0;
    for (let row of data) {
      const cell = row[colIndex]?.toString().trim();
      if (ritmRegex.test(cell)) count++;
    }
    if (count > maxCount) {
      maxCount = count;
      ritmColIndex = colIndex;
    }
  });

  if (ritmColIndex === -1) {
    throw new Error("No RITM column detected.");
  }

  // ---- Trim RITM column in-place ----
  for (let i = 0; i < data.length; i++) {
    const cellValue = data[i][ritmColIndex];
    if (typeof cellValue === "string") {
      const trimmed = cellValue.trim();
      if (trimmed !== cellValue) {
        dataRange.getCell(i, ritmColIndex).setValue(trimmed);
      }
    }
  }

  // ---- Group rows by RITM ----
  const ritmGroups: Record<string, { rowIndex: number; id: number }> = {};

  for (let i = 0; i < data.length; i++) {
    const ritmRaw = data[i][ritmColIndex]?.toString().trim();
    const idRaw = data[i][idColIndex]?.toString().trim();

    if (ritmRegex.test(ritmRaw) && !isNaN(Number(idRaw))) {
      const ritm = ritmRaw.toUpperCase();
      const id = Number(idRaw);

      // Keep only the highest ID row index
      if (!ritmGroups[ritm] || id > ritmGroups[ritm].id) {
        ritmGroups[ritm] = { rowIndex: i, id };
      }
    }
  }

  // ---- Process duplicates (bottom ‚Üí top to avoid index shift) ----
  for (let i = data.length - 1; i >= 0; i--) {
    const ritmRaw = data[i][ritmColIndex]?.toString().trim();
    const idRaw = data[i][idColIndex]?.toString().trim();

    if (!ritmRegex.test(ritmRaw) || isNaN(Number(idRaw))) continue;

    const ritm = ritmRaw.toUpperCase();
    const id = Number(idRaw);

    // If this row is NOT the latest ‚Üí archive + delete
    if (ritmGroups[ritm].id !== id) {

      // 1Ô∏è‚É£ Copy row to archive table
      archiveTable.addRow(-1, data[i]);

      // 2Ô∏è‚É£ Delete row from source table
      sourceTable.getRangeBetweenHeaderAndTotal()
        .getRow(i)
        .delete(ExcelScript.DeleteShiftDirection.up);
    }
  }
}
