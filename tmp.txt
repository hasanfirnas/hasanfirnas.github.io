function main(workbook: ExcelScript.Workbook) {

  // =========================
  // CONFIG
  // =========================
  const SOURCE_SHEET = "Sheet1";
  const SOURCE_TABLE = "OfficeForms.Table";
  const BIN_SHEET = "Bin";
  const BIN_TABLE = "Bin.Table";

  // =========================
  // LOAD TABLES
  // =========================
  const sourceTable = workbook.getWorksheet(SOURCE_SHEET).getTable(SOURCE_TABLE);
  const binTable = workbook.getWorksheet(BIN_SHEET).getTable(BIN_TABLE);

  const headers = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const dataRange = sourceTable.getRangeBetweenHeaderAndTotal();
  const data = dataRange.getValues() as (string | number | boolean)[][];

  // =========================
  // FIND Id COLUMN
  // =========================
  const idColIndex = headers.indexOf("Id");
  if (idColIndex === -1) {
    throw new Error("❌ 'Id' column not found");
  }

  // =========================
  // DETECT RITM COLUMN
  // =========================
  const ritmRegex = /^RITM\d{4,}$/i;
  let ritmColIndex = -1;
  let maxCount = 0;

  headers.forEach((_, colIndex) => {
    let count = 0;
    for (const row of data) {
      const cell = row[colIndex];
      if (typeof cell === "string" && ritmRegex.test(cell.trim())) {
        count++;
      }
    }
    if (count > maxCount) {
      maxCount = count;
      ritmColIndex = colIndex;
    }
  });

  if (ritmColIndex === -1) {
    throw new Error("❌ RITM column could not be detected");
  }

  // =========================
  // TRIM RITM VALUES IN DATA
  // =========================
  for (let i = 0; i < data.length; i++) {
    const val = data[i][ritmColIndex];
    if (typeof val === "string") {
      data[i][ritmColIndex] = val.trim();
    }
  }

  // =========================
  // GROUP ROWS BY RITM
  // =========================
  type RowEntry = {
    row: (string | number | boolean)[];
    id: number;
  };

  const groups: Record<string, RowEntry[]> = {};

  for (const row of data) {
    const ritmCell = row[ritmColIndex];
    const idCell = row[idColIndex];

    if (
      typeof ritmCell === "string" &&
      typeof idCell !== "boolean" &&
      ritmRegex.test(ritmCell.trim()) &&
      !isNaN(Number(idCell))
    ) {
      const ritmKey = ritmCell.trim().toUpperCase();
      const idValue = Number(idCell);

      if (!groups[ritmKey]) {
        groups[ritmKey] = [];
      }

      groups[ritmKey].push({
        row: row,
        id: idValue
      });
    }
  }

  // =========================
  // SPLIT KEEP vs BIN
  // =========================
  const rowsToKeep: (string | number | boolean)[][] = [];
  const rowsToBin: (string | number | boolean)[][] = [];

  for (const ritm in groups) {
    const entries = groups[ritm];

    if (entries.length === 1) {
      rowsToKeep.push(entries[0].row);
      continue;
    }

    // keep highest Id
    entries.sort((a, b) => a.id - b.id);
    const keeper = entries[entries.length - 1];

    rowsToKeep.push(keeper.row);

    for (const entry of entries) {
      if (entry !== keeper) {
        rowsToBin.push(entry.row);
      }
    }
  }

  // =========================
  // MOVE TO BIN TABLE
  // =========================
  for (const row of rowsToBin) {
    binTable.addRow(-1, row);
  }

  // =========================
  // REBUILD SOURCE TABLE
  // =========================
  if (data.length > 0) {
    sourceTable.clearRows();
  }

  for (const row of rowsToKeep) {
    sourceTable.addRow(-1, row);
  }
}
