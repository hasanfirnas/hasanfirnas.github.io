function main(workbook: ExcelScript.Workbook) {

  // =========================
  // CONFIG
  // =========================
  const SOURCE_SHEET = "Sheet1";
  const SOURCE_TABLE = "OfficeForms.Table";
  const BIN_SHEET = "Bin";
  const BIN_TABLE = "Bin.Table";

  // =========================
  // LOAD TABLES
  // =========================
  const sourceTable = workbook.getWorksheet(SOURCE_SHEET).getTable(SOURCE_TABLE);
  const binTable = workbook.getWorksheet(BIN_SHEET).getTable(BIN_TABLE);

  const headers = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const dataRange = sourceTable.getRangeBetweenHeaderAndTotal();
  const data = dataRange.getValues();

  // =========================
  // FIND Id COLUMN
  // =========================
  const idColIndex = headers.indexOf("Id");
  if (idColIndex === -1) {
    throw new Error("❌ 'Id' column not found");
  }

  // =========================
  // DETECT RITM COLUMN
  // =========================
  const ritmRegex = /^RITM\d{4,}$/i;
  let ritmColIndex = -1;
  let maxCount = 0;

  headers.forEach((_, colIndex) => {
    let count = 0;
    for (const row of data) {
      const cell = row[colIndex]?.toString().trim();
      if (ritmRegex.test(cell)) count++;
    }
    if (count > maxCount) {
      maxCount = count;
      ritmColIndex = colIndex;
    }
  });

  if (ritmColIndex === -1) {
    throw new Error("❌ RITM column could not be detected");
  }

  // =========================
  // TRIM RITM VALUES IN EXCEL
  // =========================
  for (let i = 0; i < data.length; i++) {
    const cellVal = data[i][ritmColIndex];
    if (typeof cellVal === "string") {
      const trimmed = cellVal.trim();
      if (trimmed !== cellVal) {
        dataRange.getCell(i, ritmColIndex).setValue(trimmed);
        data[i][ritmColIndex] = trimmed;
      }
    }
  }

  // =========================
  // GROUP ROWS BY RITM
  // =========================
  const groups: Record<string, { rowIndex: number; id: number }[]> = {};

  for (let i = 0; i < data.length; i++) {
    const ritm = data[i][ritmColIndex]?.toString().trim();
    const idRaw = data[i][idColIndex]?.toString().trim();

    if (ritmRegex.test(ritm) && !isNaN(Number(idRaw))) {
      const key = ritm.toUpperCase();
      if (!groups[key]) groups[key] = [];
      groups[key].push({ rowIndex: i, id: Number(idRaw) });
    }
  }

  // =========================
  // COLLECT ROWS TO MOVE
  // =========================
  const rowsToMove: number[] = [];

  for (const ritm in groups) {
    const entries = groups[ritm];
    if (entries.length <= 1) continue;

    // keep highest Id
    entries.sort((a, b) => a.id - b.id);
    const keeper = entries[entries.length - 1];

    for (const entry of entries) {
      if (entry.rowIndex !== keeper.rowIndex) {
        rowsToMove.push(entry.rowIndex);
      }
    }
  }

  // =========================
  // MOVE + DELETE (BOTTOM → TOP)
  // =========================
  rowsToMove.sort((a, b) => b - a);

  for (const rowIndex of rowsToMove) {
    const rowRange = dataRange.getRow(rowIndex);
    const rowValues = rowRange.getValues()[0];

    // 1️⃣ Move to Bin table
    binTable.addRow(-1, rowValues);

    // 2️⃣ Optional visual mark before delete
    rowRange.getFormat().getFill().setColor("red");
    rowRange.getFormat().getFont().setStrikethrough(true);

    // 3️⃣ SAFE delete (Office Scripts compliant)
    rowRange.delete(ExcelScript.DeleteShiftDirection.up);
  }
}
