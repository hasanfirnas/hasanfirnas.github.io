/**
 * Searches the output table for a given RITM and decides whether to allow a new submission.
 * Returns:
 *   - "pass:new" if allowed
 *   - "reject:<reason>" for marker reasons (Bin-Duplicate, Submitted Again)
 *   - "reject:<reason>:<email>" for detailed reasons (Active, Closed Complete, Cancelled)
 * @param workbook - The Excel workbook object.
 * @param ritmInput - The RITM ID to search for (user will be prompted).
 */

// ====================
// CONFIGURATION – Update these values as needed
// ====================
const OUTPUT_SHEET = "Output";
const OUTPUT_TABLE = "OuputTable";
const SOURCE_SHEET = "Sheet1";
const SOURCE_TABLE = "OfficeForms.Table";
const BIN_SHEET = "Bin";
const BIN_TABLE = "Bin.Table";

function main(workbook: ExcelScript.Workbook, ritmInput: string): string {
  // Validate input
  if (!ritmInput || ritmInput.trim() === "") {
    console.log("Error: No RITM ID provided.");
    return "error:no_input";
  }
  const searchRitm: string = ritmInput.trim();

  // Get the output worksheet
  const sheet: ExcelScript.Worksheet = workbook.getWorksheet(OUTPUT_SHEET);
  if (!sheet) {
    console.log(`Error: Worksheet "${OUTPUT_SHEET}" not found.`);
    return "error:sheet_not_found";
  }

  // Get the output table
  const table: ExcelScript.Table = sheet.getTable(OUTPUT_TABLE);
  if (!table) {
    console.log(`Error: Table "${OUTPUT_TABLE}" not found in sheet "${OUTPUT_SHEET}".`);
    return "error:table_not_found";
  }

  // Get headers
  const headers: string[] = table.getHeaderRowRange().getValues()[0] as string[];

  // Find column indices
  const idColIndex: number = 0;                      // First column is Id
  const ritmColIndex: number = headers.findIndex(h => /^RITM/i.test(h));
  const cmdbStatusColIndex: number = headers.indexOf("CMDB Status");

  // Validate critical columns
  if (ritmColIndex === -1) {
    console.log("Error: No column with header starting with 'RITM' found.");
    return "error:ritm_column_missing";
  }
  if (cmdbStatusColIndex === -1) {
    console.log("Warning: 'CMDB Status' column not found; status will be shown as 'N/A'.");
  }

  // Get data range (rows below headers)
  const dataRange: ExcelScript.Range = table.getRangeBetweenHeaderAndTotal();
  const data: (string | number | boolean)[][] = dataRange.getValues() as (string | number | boolean)[][];

  // Collect all rows that match the input RITM
  interface Match {
    ritm: string;
    id: string;
    status: string;
  }
  const matches: Match[] = [];

  for (let i = 0; i < data.length; i++) {
    const row = data[i];
    const cellValue = row[ritmColIndex];
    if (!cellValue) continue;

    const ritmValue: string = cellValue.toString().trim();
    if (ritmValue.toLowerCase() === searchRitm.toLowerCase()) {
      const idValue: string = row[idColIndex] ? row[idColIndex].toString() : "";
      const statusValue: string = (cmdbStatusColIndex !== -1 && row[cmdbStatusColIndex])
        ? row[cmdbStatusColIndex].toString()
        : "N/A";
      matches.push({ ritm: ritmValue, id: idValue, status: statusValue });
    }
  }

  // If no matches, it's a new RITM
  if (matches.length === 0) {
    console.log("No existing entries found.");
    return "pass:new";
  }

  // Log all matches for inspection
  console.log(`Found ${matches.length} occurrence(s) of RITM ${searchRitm}:`);
  matches.forEach((match, index) => {
    console.log(`[${index + 1}] RITM: ${match.ritm}, Id: ${match.id}, CMDB Status: ${match.status}`);
  });

  // ====================
  // DECISION LOGIC
  // ====================
  // Define blocking statuses and their priority (higher number = higher priority)
  const blockingStatusPriority: { [key: string]: number } = {
    "Cancelled": 5,
    "Closed Complete": 4,
    "Active": 3,
    "Submitted Again": 2,
    "Bin-Duplicate": 1
  };

  let highestPriority = 0;
  let reason = "";
  let responsibleId = "";  // ID of the row that caused the highest priority

  for (const match of matches) {
    const status = match.status;
    const priority = blockingStatusPriority[status];
    if (priority !== undefined && priority > highestPriority) {
      highestPriority = priority;
      reason = status;
      responsibleId = match.id;
    }
  }

  // If no blocking status found, it's pass
  if (highestPriority === 0) {
    return "pass:new";
  }

  // Determine if we need to fetch email (only for detailed reasons)
  const detailedReasons = ["Active", "Closed Complete", "Cancelled"];
  if (detailedReasons.includes(reason)) {
    const email = lookupEmail(workbook, responsibleId);
    return `reject:${reason}:${email}`;
  } else {
    // Marker reasons (Submitted Again, Bin-Duplicate) – no email
    return `reject:${reason}`;
  }
}

/**
 * Looks up an email address for a given ID, first in the source sheet, then in the bin sheet.
 * Returns the email if found, otherwise "noemail".
 */
function lookupEmail(workbook: ExcelScript.Workbook, id: string): string {
  // Try source sheet first
  let email = searchTableForEmail(workbook, SOURCE_SHEET, SOURCE_TABLE, id);
  if (email) return email;

  // Then try bin sheet
  email = searchTableForEmail(workbook, BIN_SHEET, BIN_TABLE, id);
  if (email) return email;

  // Not found anywhere
  return "noemail";
}

/**
 * Searches a specific table for a row with the given ID and returns the email from that row.
 * Returns empty string if not found or email column missing.
 */
function searchTableForEmail(
  workbook: ExcelScript.Workbook,
  sheetName: string,
  tableName: string,
  targetId: string
): string {
  const sheet = workbook.getWorksheet(sheetName);
  if (!sheet) {
    console.log(`Warning: Sheet "${sheetName}" not found.`);
    return "";
  }

  const table = sheet.getTable(tableName);
  if (!table) {
    console.log(`Warning: Table "${tableName}" not found in sheet "${sheetName}".`);
    return "";
  }

  const headers: string[] = table.getHeaderRowRange().getValues()[0] as string[];
  const idColIndex = headers.indexOf("Id");
  if (idColIndex === -1) {
    console.log(`Warning: No 'Id' column in table "${tableName}".`);
    return "";
  }

  const emailColIndex = headers.findIndex(h => /email/i.test(h));
  if (emailColIndex === -1) {
    console.log(`Warning: No 'Email' column in table "${tableName}".`);
    return "";
  }

  const dataRange = table.getRangeBetweenHeaderAndTotal();
  const data = dataRange.getValues() as (string | number | boolean)[][];

  for (const row of data) {
    const rowId = row[idColIndex] ? row[idColIndex].toString() : "";
    if (rowId === targetId) {
      const email = row[emailColIndex] ? row[emailColIndex].toString() : "";
      return email || "noemail"; // return "noemail" if email cell empty
    }
  }

  return ""; // ID not found
}
