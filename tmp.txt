function main(workbook: ExcelScript.Workbook) {
  // ====================
  // 1. CONFIGURATION
  // ====================
  const SOURCE_SHEET = "Sheet1";
  const SOURCE_TABLE = "OfficeForms.Table";
  const BIN_SHEET = "Bin";
  const BIN_TABLE = "Bin.Table";
  
  // Words in the CMDB Status column that trigger a move to the bin
  const STATUS_VALUES_TO_BIN = ["application team rejected", "cancelled", "unauthorized submission"];
  
  console.log("üöÄ Starting Bin Automation Script");
  console.log(`   Source: ${SOURCE_SHEET} -> ${SOURCE_TABLE}`);
  console.log(`   Destination: ${BIN_SHEET} -> ${BIN_TABLE}`);

  // ====================
  // 2. GET TABLES & DATA
  // ====================
  const sourceSheet = workbook.getWorksheet(SOURCE_SHEET);
  const binSheet = workbook.getWorksheet(BIN_SHEET);
  
  const sourceTable = sourceSheet.getTable(SOURCE_TABLE);
  const binTable = binSheet.getTable(BIN_TABLE);
  
  console.log("‚úÖ Tables loaded successfully.");

  // Get headers
  const sourceHeaders = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const binHeaders = binTable.getHeaderRowRange().getValues()[0] as string[];
  
  // Get all source data
  const sourceRange = sourceTable.getRangeBetweenHeaderAndTotal();
  const sourceData = sourceRange.getValues() as (string | number | boolean)[][];
  const totalSourceRows = sourceData.length;
  console.log(`üìä Processing ${totalSourceRows} rows from source table.`);

  // ====================
  // 3. FIND CRITICAL COLUMNS
  // ====================
  // Find column indices
  const idColIndex = sourceHeaders.indexOf("Id");
  const ritmColIndex = sourceHeaders.findIndex(h => /^RITM/i.test(h)); // Finds first header starting with "RITM"
  const cmdbStatusColIndex = sourceHeaders.indexOf("CMDB Status");

  // Log column findings
  console.log(`üîç Column Mapping: Id -> column ${idColIndex+1}, RITM -> column ${ritmColIndex+1}, CMDB Status -> column ${cmdbStatusColIndex+1}`);
  
  // Validate essential columns
  if (idColIndex === -1) {
    console.error("‚ùå CRITICAL: 'Id' column not found in source table. Script stopped.");
    return; // Exit instead of throw for better UX
  }
  if (ritmColIndex === -1) {
    console.warn("‚ö†Ô∏è  No column starting with 'RITM' found. Duplicate and empty checks for RITM will be skipped.");
  }
  
  // ====================
  // 4. BUILD ID SET FOR BIN (Avoid Duplicates)
  // ====================
  const binRange = binTable.getRangeBetweenHeaderAndTotal();
  const binData = binRange.getValues() as (string | number | boolean)[][];
  const binIdColIndex = binHeaders.indexOf("Id");
  const existingBinIds = new Set<string>();
  
  if (binIdColIndex !== -1) {
    for (const binRow of binData) {
      const binId = binRow[binIdColIndex];
      if (binId != null && String(binId).trim() !== "") {
        existingBinIds.add(String(binId).trim());
      }
    }
    console.log(`üì¶ Bin already contains ${existingBinIds.size} unique IDs. These will not be re-added.`);
  }

  // ====================
  // 5. IDENTIFY ROWS TO MOVE
  // ====================
  const rowsMarkedForBin = new Set<number>(); // Stores source row indices (0-based) to move
  const reasonForMove: { [key: number]: string } = {}; // Maps row index to reason

  // ----- RULE 1: Find Duplicate RITMs -----
  if (ritmColIndex !== -1) {
    const ritmGroups: { [key: string]: { rowIndex: number, id: number }[] } = {};
    
    // Group rows by their RITM value
    for (let i = 0; i < sourceData.length; i++) {
      const row = sourceData[i];
      const ritmValue = row[ritmColIndex];
      const idValue = row[idColIndex];
      
      // Only process rows with a valid RITM and ID
      if (ritmValue && String(ritmValue).trim() !== "" && idValue != null && !isNaN(Number(idValue))) {
        const ritmKey = String(ritmValue).trim().toUpperCase();
        if (!ritmGroups[ritmKey]) ritmGroups[ritmKey] = [];
        ritmGroups[ritmKey].push({ rowIndex: i, id: Number(idValue) });
      }
    }
    
    // For each RITM group, keep the newest (highest ID) and mark others
    for (const ritmKey in ritmGroups) {
      const entries = ritmGroups[ritmKey];
      if (entries.length > 1) {
        // Sort by ID ascending, so the last entry is the newest
        entries.sort((a, b) => a.id - b.id);
        const keeper = entries[entries.length - 1];
        
        for (const entry of entries) {
          if (entry.rowIndex !== keeper.rowIndex) {
            rowsMarkedForBin.add(entry.rowIndex);
            reasonForMove[entry.rowIndex] = `Duplicate RITM: '${ritmKey}'. Newer ID ${keeper.id} kept.`;
            console.log(`   ‚û°Ô∏è Row ${entry.rowIndex + 2} (ID:${entry.id}): Marked. ${reasonForMove[entry.rowIndex]}`);
          }
        }
      }
    }
  }

  // ----- RULE 2: Empty RITM Cells -----
  if (ritmColIndex !== -1) {
    for (let i = 0; i < sourceData.length; i++) {
      // Skip rows already marked by Rule 1
      if (rowsMarkedForBin.has(i)) continue;
      
      const ritmValue = sourceData[i][ritmColIndex];
      const idValue = sourceData[i][idColIndex];
      // Check if RITM cell is null, undefined, or empty string after trimming
      if (ritmValue == null || String(ritmValue).trim() === "") {
        rowsMarkedForBin.add(i);
        reasonForMove[i] = "RITM cell is empty.";
        console.log(`   ‚û°Ô∏è Row ${i + 2} (ID:${idValue}): Marked. ${reasonForMove[i]}`);
      }
    }
  }

  // ----- RULE 3: Specific CMDB Status Values -----
  if (cmdbStatusColIndex !== -1) {
    for (let i = 0; i < sourceData.length; i++) {
      if (rowsMarkedForBin.has(i)) continue; // Skip if already marked
      
      const statusValue = sourceData[i][cmdbStatusColIndex];
      const idValue = sourceData[i][idColIndex];
      
      if (statusValue != null) {
        const statusStr = String(statusValue).toLowerCase().trim();
        if (STATUS_VALUES_TO_BIN.some(badStatus => statusStr === badStatus.toLowerCase())) {
          rowsMarkedForBin.add(i);
          reasonForMove[i] = `CMDB Status is '${statusValue}'.`;
          console.log(`   ‚û°Ô∏è Row ${i + 2} (ID:${idValue}): Marked. ${reasonForMove[i]}`);
        }
      }
    }
  } else {
    console.warn("‚ö†Ô∏è  'CMDB Status' column not found. Rule 3 will be skipped.");
  }

  console.log(`‚úÖ Analysis complete. ${rowsMarkedForBin.size} rows marked for moving to bin.`);

  // ====================
  // 6. MOVE ROWS TO BIN TABLE
  // ====================
  const rowsToBinIndices = Array.from(rowsMarkedForBin).sort((a, b) => b - a); // Sort descending for deletion
  let movedCount = 0;
  let skippedCount = 0;

  console.log("--- Starting Move Process ---");
  
  for (const sourceRowIndex of rowsToBinIndices) {
    const sourceRow = sourceData[sourceRowIndex];
    const rowId = sourceRow[idColIndex];
    const rowIdStr = rowId != null ? String(rowId).trim() : "";
    
    // Skip if ID is empty or already exists in bin
    if (rowIdStr === "" || existingBinIds.has(rowIdStr)) {
      const skipReason = rowIdStr === "" ? "ID is empty" : `ID ${rowIdStr} already in bin`;
      console.log(`   ‚è≠Ô∏è Skipping row ${sourceRowIndex + 2}: ${skipReason}.`);
      skippedCount++;
      continue;
    }
    
    // Map source columns to bin columns
    const newBinRow: (string | number | boolean)[] = [];
    for (const binHeader of binHeaders) {
      const sourceColIndex = sourceHeaders.indexOf(binHeader);
      newBinRow.push(sourceColIndex !== -1 ? sourceRow[sourceColIndex] : "");
    }
    
    // Add the row to the bin table
    binTable.addRow(-1, newBinRow);
    if (rowIdStr) existingBinIds.add(rowIdStr); // Update the set
    movedCount++;
    
    console.log(`   ‚úÖ MOVED: Row ${sourceRowIndex + 2} (ID:${rowIdStr}, Reason: ${reasonForMove[sourceRowIndex]})`);
  }
  
  console.log(`--- Move Process Complete ---`);
  console.log(`   Moved: ${movedCount} rows`);
  console.log(`   Skipped: ${skippedCount} rows (duplicate or empty ID)`);

  // ====================
  // 7. DELETE ROWS FROM SOURCE
  // ====================
  if (rowsToBinIndices.length > 0) {
    console.log("üßπ Cleaning up source table...");
    // Delete from bottom to top to maintain correct indices
    for (const sourceRowIndex of rowsToBinIndices) {
      // Only delete if the row hasn't been skipped (still exists)
      if (sourceRowIndex < sourceRange.getRowCount()) {
        sourceRange.getRow(sourceRowIndex).delete(ExcelScript.DeleteShiftDirection.up);
        console.log(`   üóëÔ∏è  Deleted row ${sourceRowIndex + 2} from source.`);
      }
    }
  }

  // ====================
  // 8. FINAL SUMMARY
  // ====================
  console.log("========================================");
  console.log("üèÅ SCRIPT EXECUTION COMPLETE");
  console.log("========================================");
  console.log(`Total Rows Processed: ${totalSourceRows}`);
  console.log(`Rows Moved to Bin: ${movedCount}`);
  console.log(`Rows Remaining in Source: ${totalSourceRows - movedCount - skippedCount}`);
  console.log("");
  console.log("üìã Next Steps:");
  console.log("1. Check the 'Bin' sheet for moved rows.");
  console.log("2. Review logs above for any warnings (‚ö†Ô∏è).");
  console.log("3. If you see an error, please share a screenshot of this log.");
  console.log("========================================");
}
