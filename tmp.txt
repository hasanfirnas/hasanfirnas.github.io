function main(workbook: ExcelScript.Workbook) {

  const sourceTable = workbook.getWorksheet("Sheet1").getTable("OfficeForms.Table");
  const binTable = workbook.getWorksheet("Bin").getTable("Bin.Table");

  const headers = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const sourceRange = sourceTable.getRangeBetweenHeaderAndTotal();
  const sourceData = sourceRange.getValues();

  // Find Id column
  const idColIndex = headers.indexOf("Id");
  if (idColIndex === -1) {
    throw new Error("Id column not found in source table");
  }

  // Detect RITM column dynamically
  const ritmRegex = /^RITM\d{4,}$/i;
  let ritmColIndex = -1;
  let maxCount = 0;

  headers.forEach((_, colIndex) => {
    let count = 0;
    for (const row of sourceData) {
      const cell = row[colIndex]?.toString().trim();
      if (ritmRegex.test(cell)) count++;
    }
    if (count > maxCount) {
      maxCount = count;
      ritmColIndex = colIndex;
    }
  });

  if (ritmColIndex === -1) {
    throw new Error("RITM column could not be detected");
  }

  // Trim RITM values in Excel (in-place)
  for (let i = 0; i < sourceData.length; i++) {
    const val = sourceData[i][ritmColIndex];
    if (typeof val === "string") {
      const trimmed = val.trim();
      if (val !== trimmed) {
        sourceRange.getCell(i, ritmColIndex).setValue(trimmed);
        sourceData[i][ritmColIndex] = trimmed;
      }
    }
  }

  // Group rows by RITM
  const ritmGroups: Record<string, { rowIndex: number; id: number }> = {};

  for (let i = 0; i < sourceData.length; i++) {
    const ritmRaw = sourceData[i][ritmColIndex]?.toString().trim();
    const idRaw = sourceData[i][idColIndex]?.toString().trim();

    if (ritmRegex.test(ritmRaw) && !isNaN(Number(idRaw))) {
      const key = `${ritmRaw.toUpperCase()}_${i}`;
      ritmGroups[key] = { rowIndex: i, id: Number(idRaw) };
    }
  }

  // Build RITM â†’ rows map
  const grouped: Record<string, { rowIndex: number; id: number }[]> = {};

  Object.values(ritmGroups).forEach(({ rowIndex, id }) => {
    const ritm = sourceData[rowIndex][ritmColIndex].toString().toUpperCase();
    if (!grouped[ritm]) grouped[ritm] = [];
    grouped[ritm].push({ rowIndex, id });
  });

  // Collect rows to move (older duplicates)
  const rowsToMove: number[] = [];

  for (const ritm in grouped) {
    const entries = grouped[ritm];
    if (entries.length <= 1) continue;

    entries.sort((a, b) => a.id - b.id);
    const keeper = entries[entries.length - 1];

    for (const entry of entries) {
      if (entry.rowIndex !== keeper.rowIndex) {
        rowsToMove.push(entry.rowIndex);
      }
    }
  }

  // IMPORTANT: process from bottom to top
  rowsToMove.sort((a, b) => b - a);

  for (const rowIndex of rowsToMove) {
    const rowValues = sourceRange.getRow(rowIndex).getValues()[0];

    // Move to Bin table
    binTable.addRow(-1, rowValues);

    // Optional: formatting before delete (purely cosmetic)
    const rowRange = sourceRange.getRow(rowIndex);
    rowRange.getFormat().getFill().setColor("red");
    rowRange.getFormat().getFont().setStrikethrough(true);

    // Delete from source table
    sourceTable.deleteRowsAt(rowIndex, 1);
  }
}
