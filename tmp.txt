/**
 * Searches the output table for a given RITM and decides whether to allow a new submission.
 * @param workbook - The Excel workbook object.
 * @param ritmInput - The RITM ID to search for (user will be prompted).
 */

// ====================
// CONFIGURATION â€“ Update these values as needed
// ====================
const OUTPUT_SHEET = "Output";
const OUTPUT_TABLE = "OuputTable";

function main(workbook: ExcelScript.Workbook, ritmInput: string): void {
  // Validate input
  if (!ritmInput || ritmInput.trim() === "") {
    console.log("Error: No RITM ID provided.");
    return;
  }
  const searchRitm: string = ritmInput.trim();

  // Get the output worksheet
  const sheet: ExcelScript.Worksheet = workbook.getWorksheet(OUTPUT_SHEET);
  if (!sheet) {
    console.log(`Error: Worksheet "${OUTPUT_SHEET}" not found.`);
    return;
  }

  // Get the output table
  const table: ExcelScript.Table = sheet.getTable(OUTPUT_TABLE);
  if (!table) {
    console.log(`Error: Table "${OUTPUT_TABLE}" not found in sheet "${OUTPUT_SHEET}".`);
    return;
  }

  // Get headers
  const headers: string[] = table.getHeaderRowRange().getValues()[0] as string[];

  // Find column indices
  const idColIndex: number = 0;                      // First column is Id
  const ritmColIndex: number = headers.findIndex(h => /^RITM/i.test(h));
  const cmdbStatusColIndex: number = headers.indexOf("CMDB Status");

  // Validate critical columns
  if (ritmColIndex === -1) {
    console.log("Error: No column with header starting with 'RITM' found.");
    return;
  }
  if (cmdbStatusColIndex === -1) {
    console.log("Warning: 'CMDB Status' column not found; status will be shown as 'N/A'.");
  }

  // Get data range (rows below headers)
  const dataRange: ExcelScript.Range = table.getRangeBetweenHeaderAndTotal();
  const data: (string | number | boolean)[][] = dataRange.getValues() as (string | number | boolean)[][];

  // Collect all rows that match the input RITM
  interface Match {
    ritm: string;
    id: string;
    status: string;
  }
  const matches: Match[] = [];

  for (let i = 0; i < data.length; i++) {
    const row = data[i];
    const cellValue = row[ritmColIndex];
    if (!cellValue) continue;

    const ritmValue: string = cellValue.toString().trim();
    if (ritmValue.toLowerCase() === searchRitm.toLowerCase()) {
      const idValue: string = row[idColIndex] ? row[idColIndex].toString() : "";
      const statusValue: string = (cmdbStatusColIndex !== -1 && row[cmdbStatusColIndex])
        ? row[cmdbStatusColIndex].toString()
        : "N/A";
      matches.push({ ritm: ritmValue, id: idValue, status: statusValue });
    }
  }

  // If no matches, it's a new RITM
  if (matches.length === 0) {
    console.log("pass:new");
    return;
  }

  // Log all matches for inspection
  console.log(`Found ${matches.length} occurrence(s) of RITM ${searchRitm}:`);
  matches.forEach((match, index) => {
    console.log(`[${index + 1}] RITM: ${match.ritm}, Id: ${match.id}, CMDB Status: ${match.status}`);
  });

  // ====================
  // DECISION LOGIC
  // ====================
  // Define blocking statuses and their priority (higher number = higher priority)
  const blockingStatusPriority: { [key: string]: number } = {
    "Cancelled": 5,
    "Closed Complete": 4,
    "Active": 3,
    "Submitted Again": 2,
    "Bin-Duplicate": 1
  };

  let highestPriority = 0;
  let reason = "";

  for (const match of matches) {
    const status = match.status;
    const priority = blockingStatusPriority[status];
    if (priority !== undefined && priority > highestPriority) {
      highestPriority = priority;
      reason = status;
    }
  }

  // Output final decision
  if (highestPriority > 0) {
    console.log(`reject:${reason}`);
  } else {
    console.log("pass:new");
  }
}
