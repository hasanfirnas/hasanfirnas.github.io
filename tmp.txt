function main(workbook: ExcelScript.Workbook) {

  const SOURCE_SHEET = "Sheet1";
  const SOURCE_TABLE = "OfficeForms.Table";
  const BIN_SHEET = "Bin";
  const BIN_TABLE = "Bin.Table";

  const sourceTable = workbook.getWorksheet(SOURCE_SHEET).getTable(SOURCE_TABLE);
  const binTable = workbook.getWorksheet(BIN_SHEET).getTable(BIN_TABLE);

  const headers = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const dataRange = sourceTable.getRangeBetweenHeaderAndTotal();
  const data = dataRange.getValues();

  // -------------------------
  // Find Id column
  // -------------------------
  const idColIndex = headers.indexOf("Id");
  if (idColIndex === -1) {
    throw new Error("Id column not found");
  }

  // -------------------------
  // Detect RITM column
  // -------------------------
  const ritmRegex = /^RITM\d{4,}$/i;
  let ritmColIndex = -1;
  let maxCount = 0;

  headers.forEach((_, colIndex) => {
    let count = 0;
    for (const row of data) {
      const cell = row[colIndex]?.toString().trim();
      if (ritmRegex.test(cell)) count++;
    }
    if (count > maxCount) {
      maxCount = count;
      ritmColIndex = colIndex;
    }
  });

  if (ritmColIndex === -1) {
    throw new Error("RITM column not detected");
  }

  // -------------------------
  // Normalize RITM values
  // -------------------------
  for (let i = 0; i < data.length; i++) {
    const v = data[i][ritmColIndex];
    if (typeof v === "string") {
      data[i][ritmColIndex] = v.trim();
    }
  }

  // -------------------------
  // Group by RITM
  // -------------------------
  const groups: Record<string, { row: any[]; id: number }[]> = {};

  for (const row of data) {
    const ritm = row[ritmColIndex]?.toString().trim();
    const idRaw = row[idColIndex]?.toString().trim();

    if (ritmRegex.test(ritm) && !isNaN(Number(idRaw))) {
      const key = ritm.toUpperCase();
      if (!groups[key]) groups[key] = [];
      groups[key].push({ row, id: Number(idRaw) });
    }
  }

  const rowsToKeep: any[][] = [];
  const rowsToBin: any[][] = [];

  // -------------------------
  // Decide keep vs bin
  // -------------------------
  for (const ritm in groups) {
    const entries = groups[ritm];

    if (entries.length === 1) {
      rowsToKeep.push(entries[0].row);
      continue;
    }

    entries.sort((a, b) => a.id - b.id);
    const keeper = entries[entries.length - 1];

    rowsToKeep.push(keeper.row);

    for (const entry of entries) {
      if (entry !== keeper) {
        rowsToBin.push(entry.row);
      }
    }
  }

  // -------------------------
  // Move duplicates to Bin
  // -------------------------
  for (const row of rowsToBin) {
    binTable.addRow(-1, row);
  }

  // -------------------------
  // Rebuild source table
  // -------------------------
  if (data.length > 0) {
    sourceTable.clearRows();
  }

  for (const row of rowsToKeep) {
    sourceTable.addRow(-1, row);
  }
}
