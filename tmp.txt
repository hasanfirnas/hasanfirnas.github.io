function main(workbook: ExcelScript.Workbook, ritmInput: string): string {

  // ---------------- CONFIG ----------------
  const OUTPUT_TABLE_NAME = "OutputTable";
  const FORMS_TABLE_NAME  = "OfficeForms.Table";
  // ----------------------------------------

  if (!ritmInput || ritmInput.trim() === "") {
    return JSON.stringify({ status: "error", message: "Empty RITM" });
  }

  const ritm = ritmInput.trim().toLowerCase();

  // ---------- STEP 1: Check OutputTable ----------
  const outputTable = workbook.getTable(OUTPUT_TABLE_NAME);
  const outputRows = outputTable
    .getRangeBetweenHeaderAndTotal()
    .getValues();

  const matchedIds: string[] = [];

  for (let i = 0; i < outputRows.length; i++) {
    const row = outputRows[i];
    const rowRitm = String(row[2] ?? "").trim().toLowerCase(); // Column C (RITM)

    if (rowRitm === ritm) {
      matchedIds.push(String(row[0] ?? "").trim()); // Column A (ID)
    }
  }

  // RITM never processed before
  if (matchedIds.length === 0) {
    return JSON.stringify({ status: "new" });
  }

  // ---------- STEP 2: Scan OfficeForms.Table ----------
  const formsTable = workbook.getTable(FORMS_TABLE_NAME);
  const formsRange = formsTable.getRangeBetweenHeaderAndTotal();
  const formsValues = formsRange.getValues();

  const worksheet = formsTable.getWorksheet();
  const totalCols = formsRange.getColumnCount();

  for (let i = 0; i < formsValues.length; i++) {
    const row = formsValues[i];
    const formId = String(row[0] ?? "").trim(); // Column A (ID)

    if (!matchedIds.includes(formId)) continue;

    const absoluteRowIndex = formsRange.getRowIndex() + i;
    const rowRange = worksheet.getRangeByIndexes(
      absoluteRowIndex,
      0,
      1,
      totalCols
    );

    // ---------- STRIKE-THROUGH CHECK (ENTIRE ROW) ----------
    let rowStruck = false;
    try {
      const strikeInfo = rowRange.getFormat().getFont().getStrikethrough();
      if (typeof strikeInfo === "boolean") {
        rowStruck = strikeInfo;
      } else if (Array.isArray(strikeInfo)) {
        outer: for (let r = 0; r < strikeInfo.length; r++) {
          for (let c = 0; c < strikeInfo[r].length; c++) {
            if (strikeInfo[r][c]) {
              rowStruck = true;
              break outer;
            }
          }
        }
      }
    } catch {}

    // ---------- COLOR CHECK (ENTIRE ROW) ----------
    let rowColored = false;
    try {
      const fillInfo = rowRange.getFormat().getFill().getColor();
      if (typeof fillInfo === "string" && fillInfo !== "") {
        rowColored = true;
      } else if (Array.isArray(fillInfo)) {
        outer2: for (let r = 0; r < fillInfo.length; r++) {
          for (let c = 0; c < fillInfo[r].length; c++) {
            if (fillInfo[r][c]) {
              rowColored = true;
              break outer2;
            }
          }
        }
      }
    } catch {}

    // ---------- ACTIVE DUPLICATE FOUND ----------
    if (!rowStruck && !rowColored) {
      const email = String(row[3] ?? "").trim(); // Column D (Email)

      return JSON.stringify({
        status: "duplicate_active",
        details: {
          id: formId,
          ritm: ritmInput,
          email: email,
          rowNumber: absoluteRowIndex + 1
        }
      });
    }
  }

  // ---------- Only rejected / struck rows exist ----------
  return JSON.stringify({
    status: "new",
    reason: "all_previous_entries_rejected"
  });
}
