function main(workbook: ExcelScript.Workbook) {

  const SOURCE_SHEET = "Sheet1";
  const SOURCE_TABLE = "OfficeForms.Table";
  const BIN_SHEET = "Bin";
  const BIN_TABLE = "Bin.Table";

  const sourceTable = workbook.getWorksheet(SOURCE_SHEET).getTable(SOURCE_TABLE);
  const binTable = workbook.getWorksheet(BIN_SHEET).getTable(BIN_TABLE);

  const sourceHeaders = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const binHeaders = binTable.getHeaderRowRange().getValues()[0] as string[];

  const sourceRange = sourceTable.getRangeBetweenHeaderAndTotal();
  const sourceData = sourceRange.getValues() as (string | number | boolean)[][];

  // ------------------------
  // Find Id column
  // ------------------------
  const idColIndex = sourceHeaders.indexOf("Id");
  if (idColIndex === -1) {
    throw new Error("Id column not found in source table");
  }

  // ------------------------
  // Detect RITM column
  // ------------------------
  const ritmRegex = /^RITM\d{4,}$/i;
  let ritmColIndex = -1;
  let maxHits = 0;

  sourceHeaders.forEach((_, colIndex) => {
    let hits = 0;
    for (const row of sourceData) {
      const cell = row[colIndex];
      if (typeof cell === "string" && ritmRegex.test(cell.trim())) {
        hits++;
      }
    }
    if (hits > maxHits) {
      maxHits = hits;
      ritmColIndex = colIndex;
    }
  });

  if (ritmColIndex === -1) {
    throw new Error("RITM column not detected");
  }

  // ------------------------
  // Normalize RITM values (in-memory)
  // ------------------------
  for (let i = 0; i < sourceData.length; i++) {
    const val = sourceData[i][ritmColIndex];
    if (typeof val === "string") {
      sourceData[i][ritmColIndex] = val.trim();
    }
  }

  // ------------------------
  // Group by RITM
  // ------------------------
  type Entry = {
    rowIndex: number;
    row: (string | number | boolean)[];
    id: number;
  };

  const groups: Record<string, Entry[]> = {};

  for (let i = 0; i < sourceData.length; i++) {
    const row = sourceData[i];
    const ritmCell = row[ritmColIndex];
    const idCell = row[idColIndex];

    if (
      typeof ritmCell === "string" &&
      ritmRegex.test(ritmCell) &&
      typeof idCell !== "boolean" &&
      !isNaN(Number(idCell))
    ) {
      const key = ritmCell.toUpperCase();
      if (!groups[key]) groups[key] = [];
      groups[key].push({ rowIndex: i, row, id: Number(idCell) });
    }
  }

  const rowsToKeep: (string | number | boolean)[][] = [];
  const rowsToBin: Entry[] = [];

  // ------------------------
  // Decide KEEP vs BIN (preserve rowIndex for deletion)
  // ------------------------
  for (const ritm in groups) {
    const entries = groups[ritm];

    if (entries.length === 1) {
      rowsToKeep.push(entries[0].row);
      continue;
    }

    entries.sort((a, b) => a.id - b.id);
    const keeper = entries[entries.length - 1];
    rowsToKeep.push(keeper.row);

    for (const e of entries) {
      if (e !== keeper) {
        rowsToBin.push(e); // store full entry so we can delete by original index
      }
    }
  }

  // ------------------------
  // Move rows to Bin (column-safe mapping)
  // ------------------------
  for (const e of rowsToBin) {
    const srcRow = e.row;
    const binRow: (string | number | boolean)[] = [];

    for (const binHeader of binHeaders) {
      const srcIndex = sourceHeaders.indexOf(binHeader);
      binRow.push(srcIndex !== -1 ? srcRow[srcIndex] : "");
    }

    binTable.addRow(-1, binRow);
  }

  // ------------------------
  // Delete source table rows (bottom -> top) to avoid index shift
  // ------------------------
  // We will delete all rows that we moved to bin by using their original rowIndex.
  // Deleting from largest index to smallest prevents shifting issues.
  if (rowsToBin.length > 0) {
    // Extract unique row indexes and sort descending
    const indexesToDelete = Array.from(new Set(rowsToBin.map(x => x.rowIndex)));
    indexesToDelete.sort((a, b) => b - a);

    for (const idx of indexesToDelete) {
      // delete the table-row-sized range; this removes the table row completely
      sourceRange.getRow(idx).delete(ExcelScript.DeleteShiftDirection.up);
    }
  }

  // ------------------------
  // At this point, some original rows were deleted. Now rebuild: 
  // remove any remaining rows in the source table and re-add rowsToKeep
  // (This ensures exact, clean table with only kept rows.)
  // ------------------------

  // Delete all remaining rows in the table (if any) bottom->top
  let remainingCount = sourceTable.getRowCount();
  for (let r = remainingCount - 1; r >= 0; r--) {
    // After prior deletes, sourceRange changed; get the current range and delete rows
    sourceTable.getRangeBetweenHeaderAndTotal().getRow(r).delete(ExcelScript.DeleteShiftDirection.up);
  }

  // Re-add the kept rows
  for (const row of rowsToKeep) {
    sourceTable.addRow(-1, row);
  }
}
