function main(workbook: ExcelScript.Workbook) {
  // ====================
  // 1. CONFIGURATION & TOGGLES
  // ====================
  const SOURCE_SHEET = "Sheet1";
  const SOURCE_TABLE = "OfficeForms.Table";
  const BIN_SHEET = "Bin";
  const BIN_TABLE = "Bin.Table";
  const OUTPUT_SHEET = "Output";
  const OUTPUT_TABLE = "OuputTabel"; // As per your spelling
  
  // CMDB Status values that trigger move to bin (Rule 3)
  const STATUS_VALUES_TO_BIN = ["application team rejected", "cancelled", "unauthorized submission"];
  
  // STATUS FIX 1: Added "cancelled" to preserve list
  const PRESERVE_STATUSES = ["application team rejected", "unauthorized submission", "cancelled"];
  
  // LOGGING CONTROL - COMMENT THIS LINE FOR PRODUCTION/POWER AUTOMATE
  const ENABLE_LOGGING = true;
  
  // ====================
  // 2. LOGGING SYSTEM (Development Only)
  // ====================
  let logSheet: ExcelScript.Worksheet | null = null;
  let logTable: ExcelScript.Table | null = null;
  
  if (ENABLE_LOGGING) {
    try {
      // Remove existing log sheet if it exists
      try {
        const oldLogSheet = workbook.getWorksheet("Script_Logs");
        oldLogSheet.delete();
      } catch (e) { /* Sheet doesn't exist */ }
      
      // Create new log sheet
      logSheet = workbook.addWorksheet("Script_Logs");
      logSheet.getRange("A1:E1").setValues([["Timestamp", "Row_ID", "RITM", "Action", "Details"]]);
      logTable = logSheet.addTable("A1:E1", true);
      logTable.setName("ScriptLogs");
      
      console.log("üìã Log sheet created: 'Script_Logs'");
    } catch (error) {
      console.log("‚ö†Ô∏è Could not create log sheet. Continuing without logs.");
    }
  }
  
  function addLog(rowId: string, ritm: string, action: string, details: string) {
    if (!ENABLE_LOGGING || !logTable) return;
    
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
      logTable.addRow(-1, [timestamp, rowId, ritm, action, details]);
    } catch (e) {
      // Silent fail for logging errors
    }
  }
  
  // ====================
  // 3. INITIALIZATION
  // ====================
  console.log("üöÄ Starting Enhanced Bin Automation");
  
  // Load all worksheets and tables
  const sourceSheet = workbook.getWorksheet(SOURCE_SHEET);
  const binSheet = workbook.getWorksheet(BIN_SHEET);
  const outputSheet = workbook.getWorksheet(OUTPUT_SHEET);
  
  if (!sourceSheet || !binSheet) {
    console.log("‚ùå Source or Bin sheet not found");
    return;
  }
  
  const sourceTable = sourceSheet.getTable(SOURCE_TABLE);
  const binTable = binSheet.getTable(BIN_TABLE);
  
  if (!sourceTable || !binTable) {
    console.log("‚ùå Source or Bin table not found");
    return;
  }
  
  // Get source data
  const sourceHeaders = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const sourceRange = sourceTable.getRangeBetweenHeaderAndTotal();
  const sourceData = sourceRange.getValues() as (string | number | boolean)[][];
  const totalSourceRows = sourceData.length;
  
  console.log(`üìä Processing ${totalSourceRows} rows from source`);
  
  // ====================
  // 4. FIND COLUMN INDICES
  // ====================
  const idColIndex = sourceHeaders.indexOf("Id");
  const ritmColIndex = sourceHeaders.findIndex(h => /^RITM/i.test(h));
  const cmdbStatusColIndex = sourceHeaders.indexOf("CMDB Status");
  
  if (idColIndex === -1) {
    console.log("‚ùå 'Id' column not found in source table");
    return;
  }
  
  // Prepare output sheet if needed for updates
  let outputTable: ExcelScript.Table | undefined;
  let outputIdColIndex = -1;
  let outputCmdbColIndex = -1;
  
  if (outputSheet) {
    try {
      outputTable = outputSheet.getTable(OUTPUT_TABLE);
      if (outputTable) {
        const outputHeaders = outputTable.getHeaderRowRange().getValues()[0] as string[];
        outputIdColIndex = outputHeaders.indexOf("Id");
        outputCmdbColIndex = outputHeaders.indexOf("CMDB Status");
      }
    } catch (e) {
      console.log("‚ö†Ô∏è Output table not found or accessible. CMDB updates will only affect source sheet.");
    }
  }
  
  // ====================
  // 5. EXISTING BIN IDs (Avoid Duplicates)
  // ====================
  const binRange = binTable.getRangeBetweenHeaderAndTotal();
  const binData = binRange.getValues() as (string | number | boolean)[][];
  const binHeaders = binTable.getHeaderRowRange().getValues()[0] as string[];
  const binIdColIndex = binHeaders.indexOf("Id");
  const existingBinIds = new Set<string>();
  
  if (binIdColIndex !== -1) {
    for (const row of binData) {
      const id = row[binIdColIndex];
      if (id != null && String(id).trim() !== "") {
        existingBinIds.add(String(id).trim());
      }
    }
  }
  
  // ====================
  // 6. IDENTIFY ROWS TO MOVE (Three Rules)
  // ====================
  const rowsMarkedForBin = new Set<number>();
  const rowReasons: { [key: number]: string } = {};
  const rowStatuses: { [key: number]: string } = {};
  
  // RULE 1: Duplicate RITMs (Keep newest/highest ID)
  if (ritmColIndex !== -1) {
    const ritmGroups: { [key: string]: { rowIndex: number, id: number }[] } = {};
    
    for (let i = 0; i < sourceData.length; i++) {
      const ritmValue = sourceData[i][ritmColIndex];
      const idValue = sourceData[i][idColIndex];
      
      if (ritmValue && String(ritmValue).trim() !== "" && idValue != null) {
        const ritmKey = String(ritmValue).trim().toUpperCase();
        const idNum = Number(idValue);
        
        if (!isNaN(idNum)) {
          if (!ritmGroups[ritmKey]) ritmGroups[ritmKey] = [];
          ritmGroups[ritmKey].push({ rowIndex: i, id: idNum });
        }
      }
    }
    
    for (const ritmKey in ritmGroups) {
      const entries = ritmGroups[ritmKey];
      if (entries.length > 1) {
        entries.sort((a, b) => a.id - b.id);
        const keeper = entries[entries.length - 1];
        
        for (const entry of entries) {
          if (entry.rowIndex !== keeper.rowIndex) {
            rowsMarkedForBin.add(entry.rowIndex);
            rowReasons[entry.rowIndex] = `Duplicate RITM '${ritmKey}'`;
            addLog(String(entry.id), ritmKey, "MARK_DUPLICATE", `Older duplicate of ID ${keeper.id}`);
          }
        }
      }
    }
  }
  
  // RULE 2: Empty RITM Cells
  if (ritmColIndex !== -1) {
    for (let i = 0; i < sourceData.length; i++) {
      if (rowsMarkedForBin.has(i)) continue;
      
      const ritmValue = sourceData[i][ritmColIndex];
      if (ritmValue == null || String(ritmValue).trim() === "") {
        rowsMarkedForBin.add(i);
        rowReasons[i] = "Empty RITM";
        const idValue = sourceData[i][idColIndex];
        addLog(String(idValue), "", "MARK_EMPTY_RITM", "RITM cell is empty");
      }
    }
  }
  
  // RULE 3: Specific CMDB Status Values
  if (cmdbStatusColIndex !== -1) {
    for (let i = 0; i < sourceData.length; i++) {
      if (rowsMarkedForBin.has(i)) continue;
      
      const statusValue = sourceData[i][cmdbStatusColIndex];
      if (statusValue != null) {
        const statusStr = String(statusValue).toLowerCase().trim();
        if (STATUS_VALUES_TO_BIN.some(badStatus => statusStr === badStatus.toLowerCase())) {
          rowsMarkedForBin.add(i);
          rowReasons[i] = `CMDB Status: '${statusValue}'`;
          rowStatuses[i] = String(statusValue); // Store original status
          const idValue = sourceData[i][idColIndex];
          addLog(String(idValue), "", "MARK_STATUS", `Status: ${statusValue}`);
        }
      }
    }
  }
  
  console.log(`‚úÖ Analysis complete: ${rowsMarkedForBin.size} rows to process`);
  
  // ====================
  // 7. UPDATE CMDB STATUS & MOVE TO BIN
  // ====================
  const rowsToProcess = Array.from(rowsMarkedForBin).sort((a, b) => b - a); // Descending for safe deletion
  let movedCount = 0;
  let skippedCount = 0;
  let updatedCount = 0;
  
  for (const sourceRowIndex of rowsToProcess) {
    const sourceRow = sourceData[sourceRowIndex];
    const rowId = sourceRow[idColIndex];
    const rowIdStr = rowId != null ? String(rowId).trim() : "";
    
    // Skip if no ID or already in bin
    if (rowIdStr === "" || existingBinIds.has(rowIdStr)) {
      skippedCount++;
      continue;
    }
    
    const ritmValue = ritmColIndex !== -1 ? sourceRow[ritmColIndex] : "";
    const ritmStr = ritmValue != null ? String(ritmValue).trim() : "";
    
    // STEP 1: Update CMDB Status if needed
    if (cmdbStatusColIndex !== -1) {
      const currentStatus = sourceRow[cmdbStatusColIndex];
      const statusStr = currentStatus != null ? String(currentStatus).trim() : "";
      
      // Check if we should update to "bin-duplicate"
      const shouldUpdate = statusStr !== "" && 
                          !PRESERVE_STATUSES.some(preserve => 
                            statusStr.toLowerCase() === preserve.toLowerCase());
      
      if (shouldUpdate) {
        // Update source sheet
        const sourceStatusCell = sourceRange.getCell(sourceRowIndex, cmdbStatusColIndex);
        sourceStatusCell.setValue("bin-duplicate");
        
        // CRITICAL FIX 2: Update the sourceData array too!
        sourceData[sourceRowIndex][cmdbStatusColIndex] = "bin-duplicate";
        
        // Update output sheet if available
        if (outputTable && outputIdColIndex !== -1 && outputCmdbColIndex !== -1) {
          const outputRange = outputTable.getRangeBetweenHeaderAndTotal();
          const outputData = outputRange.getValues() as (string | number | boolean)[][];
          
          for (let j = 0; j < outputData.length; j++) {
            const outputId = outputData[j][outputIdColIndex];
            if (outputId != null && String(outputId).trim() === rowIdStr) {
              const outputStatusCell = outputRange.getCell(j, outputCmdbColIndex);
              outputStatusCell.setValue("bin-duplicate");
              updatedCount++;
              addLog(rowIdStr, ritmStr, "UPDATE_STATUS", `Updated both sheets to 'bin-duplicate'`);
              break;
            }
          }
        } else {
          addLog(rowIdStr, ritmStr, "UPDATE_STATUS", `Updated source sheet to 'bin-duplicate'`);
        }
      } else {
        // If status is "cancelled", "application team rejected", or "unauthorized submission"
        addLog(rowIdStr, ritmStr, "PRESERVE_STATUS", `Keeping original status: '${statusStr}'`);
      }
    }
    
    // STEP 2: Move to Bin table (NOW with updated data)
    const newBinRow: (string | number | boolean)[] = [];
    for (const binHeader of binHeaders) {
      const sourceColIndex = sourceHeaders.indexOf(binHeader);
      newBinRow.push(sourceColIndex !== -1 ? sourceData[sourceRowIndex][sourceColIndex] : "");
    }
    
    binTable.addRow(-1, newBinRow);
    existingBinIds.add(rowIdStr);
    movedCount++;
    
    // STEP 3: Apply strikethrough in Bin
    try {
      const newBinRange = binTable.getRangeBetweenHeaderAndTotal();
      const lastRowIndex = newBinRange.getRowCount() - 1;
      if (lastRowIndex >= 0) {
        const lastRow = newBinRange.getRow(lastRowIndex);
        lastRow.getFormat().getFont().setStrikethrough(true);
      }
    } catch (e) {
      // Silent fail on formatting
    }
    
    addLog(rowIdStr, ritmStr, "MOVED_TO_BIN", `Reason: ${rowReasons[sourceRowIndex]}`);
  }
  
  // ====================
  // 8. DELETE FROM SOURCE
  // ====================
  if (rowsToProcess.length > 0) {
    // Need to refresh range after potential modifications
    const updatedSourceRange = sourceTable.getRangeBetweenHeaderAndTotal();
    
    for (const sourceRowIndex of rowsToProcess) {
      if (sourceRowIndex < updatedSourceRange.getRowCount()) {
        updatedSourceRange.getRow(sourceRowIndex).delete(ExcelScript.DeleteShiftDirection.up);
      }
    }
  }
  
  // ====================
  // 9. FINAL SUMMARY
  // ====================
  console.log("=".repeat(50));
  console.log("üèÅ SCRIPT EXECUTION COMPLETE");
  console.log("=".repeat(50));
  console.log(`Total Rows Processed: ${totalSourceRows}`);
  console.log(`Rows Moved to Bin: ${movedCount}`);
  console.log(`Rows Skipped: ${skippedCount} (duplicate IDs or empty)`);
  console.log(`CMDB Status Updates: ${updatedCount}`);
  console.log("");
  
  if (ENABLE_LOGGING) {
    console.log("üìã Detailed logs available in 'Script_Logs' sheet");
    console.log("   To disable logging for production, comment out line 22:");
    console.log("   // const ENABLE_LOGGING = true;");
  }
  
  console.log("=".repeat(50));
}
