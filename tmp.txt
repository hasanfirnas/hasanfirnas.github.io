function main(workbook: ExcelScript.Workbook) {
  console.log("üîç DIAGNOSTIC SCRIPT - Checking Output Sheet");
  console.log("=============================================");
  
  // ====================
  // 1. CHECK OUTPUT SHEET
  // ====================
  const OUTPUT_SHEET = "Output";
  const OUTPUT_TABLE = "OuputTabel"; // With your spelling
  
  console.log("\nüìÑ CHECKING OUTPUT SHEET:");
  console.log("Looking for sheet named: '" + OUTPUT_SHEET + "'");
  
  const outputSheet = workbook.getWorksheet(OUTPUT_SHEET);
  
  if (!outputSheet) {
    console.log("‚ùå PROBLEM: Output sheet NOT FOUND!");
    console.log("Available sheets in your workbook:");
    const allSheets = workbook.getWorksheets();
    for (let i = 0; i < allSheets.length; i++) {
      console.log("  - " + allSheets[i].getName());
    }
    return; // Stop here
  }
  
  console.log("‚úÖ Output sheet FOUND!");
  
  // ====================
  // 2. CHECK OUTPUT TABLE
  // ====================
  console.log("\nüìä CHECKING OUTPUT TABLE:");
  console.log("Looking for table named: '" + OUTPUT_TABLE + "'");
  
  let outputTable: ExcelScript.Table;
  try {
    outputTable = outputSheet.getTable(OUTPUT_TABLE);
    console.log("‚úÖ Output table FOUND!");
  } catch (e) {
    console.log("‚ùå PROBLEM: Output table NOT FOUND!");
    console.log("Available tables in Output sheet:");
    
    try {
      const allTables = outputSheet.getTables();
      for (let i = 0; i < allTables.length; i++) {
        console.log("  - " + allTables[i].getName());
      }
    } catch (err) {
      console.log("  No tables found in Output sheet");
    }
    return; // Stop here
  }
  
  // ====================
  // 3. CHECK COLUMNS
  // ====================
  console.log("\nüè∑Ô∏è CHECKING COLUMNS IN OUTPUT TABLE:");
  
  const outputHeaders = outputTable.getHeaderRowRange().getValues()[0] as string[];
  console.log("Total columns: " + outputHeaders.length);
  console.log("Column names:");
  
  for (let i = 0; i < outputHeaders.length; i++) {
    console.log("  " + (i + 1) + ". '" + outputHeaders[i] + "'");
  }
  
  // Look for specific columns
  const idColIndex = outputHeaders.indexOf("Id");
  const cmdbColIndex = outputHeaders.indexOf("CMDB Status");
  
  console.log("\nüîé LOOKING FOR IMPORTANT COLUMNS:");
  console.log("'Id' column: " + (idColIndex !== -1 ? "FOUND at position " + (idColIndex + 1) : "NOT FOUND"));
  console.log("'CMDB Status' column: " + (cmdbColIndex !== -1 ? "FOUND at position " + (cmdbColIndex + 1) : "NOT FOUND"));
  
  // ====================
  // 4. CHECK SAMPLE DATA
  // ====================
  console.log("\nüìà CHECKING SAMPLE DATA:");
  
  const outputRange = outputTable.getRangeBetweenHeaderAndTotal();
  const outputData = outputRange.getValues() as (string | number | boolean)[][];
  const rowCount = outputData.length;
  
  console.log("Total rows in Output table: " + rowCount);
  
  if (rowCount === 0) {
    console.log("‚ÑπÔ∏è Output table is EMPTY (no data rows)");
    return;
  }
  
  // Show first 3 rows as samples
  console.log("\nSAMPLE ROWS (first 3):");
  for (let i = 0; i < Math.min(3, rowCount); i++) {
    const row = outputData[i];
    console.log("\nRow " + (i + 1) + ":");
    
    if (idColIndex !== -1) {
      console.log("  ID: '" + row[idColIndex] + "'");
    }
    
    if (cmdbColIndex !== -1) {
      console.log("  CMDB Status: '" + row[cmdbColIndex] + "'");
    }
    
    // Show other columns too
    console.log("  Full row data: " + JSON.stringify(row));
  }
  
  // ====================
  // 5. CHECK BIN SHEET (for comparison)
  // ====================
  console.log("\nüóëÔ∏è CHECKING BIN SHEET (for comparison):");
  
  try {
    const binSheet = workbook.getWorksheet("Bin");
    if (binSheet) {
      const binTable = binSheet.getTable("Bin.Table");
      if (binTable) {
        const binHeaders = binTable.getHeaderRowRange().getValues()[0] as string[];
        const binIdColIndex = binHeaders.indexOf("Id");
        const binCmdbColIndex = binHeaders.indexOf("CMDB Status");
        
        const binRange = binTable.getRangeBetweenHeaderAndTotal();
        const binData = binRange.getValues() as (string | number | boolean)[][];
        const binRowCount = binData.length;
        
        console.log("Bin rows: " + binRowCount);
        
        // Show IDs in Bin that should be in Output
        console.log("\nIDs currently in Bin sheet:");
        if (binIdColIndex !== -1 && binRowCount > 0) {
          for (let i = 0; i < Math.min(5, binRowCount); i++) {
            const id = binData[i][binIdColIndex];
            const cmdb = binCmdbColIndex !== -1 ? binData[i][binCmdbColIndex] : "N/A";
            console.log("  ID: '" + id + "' | CMDB: '" + cmdb + "'");
          }
          if (binRowCount > 5) {
            console.log("  ... and " + (binRowCount - 5) + " more");
          }
        }
      }
    }
  } catch (e) {
    console.log("‚ÑπÔ∏è Could not check Bin sheet");
  }
  
  // ====================
  // 6. CHECK SPECIFIC IDs
  // ====================
  console.log("\nüî¨ CHECKING IF SPECIFIC IDs EXIST IN OUTPUT:");
  
  if (idColIndex !== -1 && rowCount > 0) {
    // Let's check a few IDs
    const testIds = [];
    
    // Add first ID from output
    testIds.push(String(outputData[0][idColIndex]));
    
    // Add a few more if available
    if (rowCount > 1) testIds.push(String(outputData[1][idColIndex]));
    if (rowCount > 2) testIds.push(String(outputData[2][idColIndex]));
    
    console.log("Checking these IDs in Output table:");
    
    for (const testId of testIds) {
      let found = false;
      let foundRow = -1;
      
      for (let j = 0; j < rowCount; j++) {
        const outputId = outputData[j][idColIndex];
        if (outputId != null && String(outputId).trim() === testId.trim()) {
          found = true;
          foundRow = j + 1;
          break;
        }
      }
      
      console.log("  ID '" + testId + "': " + (found ? "‚úÖ FOUND at row " + foundRow : "‚ùå NOT FOUND"));
    }
  }
  
  console.log("\n=============================================");
  console.log("üîç DIAGNOSTIC COMPLETE");
  console.log("=============================================");
  console.log("\nüìã PLEASE SHARE THIS FULL OUTPUT WITH ME.");
  console.log("It will show me exactly what's wrong!");
}


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


function main(workbook: ExcelScript.Workbook) {
  // ====================
  // 1. CONFIGURATION & TOGGLES
  // ====================
  const SOURCE_SHEET = "Sheet1";
  const SOURCE_TABLE = "OfficeForms.Table";
  const BIN_SHEET = "Bin";
  const BIN_TABLE = "Bin.Table";
  const OUTPUT_SHEET = "Output";
  const OUTPUT_TABLE = "OuputTabel"; // As per your spelling
  
  // CMDB Status values that trigger move to bin (Rule 3)
  const STATUS_VALUES_TO_BIN = ["application team rejected", "cancelled", "unauthorized submission"];
  
  // Status values that should NOT be changed to "bin-duplicate"
  const PRESERVE_STATUSES = ["application team rejected", "unauthorized submission", "cancelled"];
  
  // LOGGING CONTROL - COMMENT THIS LINE FOR PRODUCTION/POWER AUTOMATE
  const ENABLE_LOGGING = true;
  
  // ====================
  // 2. LOGGING SYSTEM (Development Only)
  // ====================
  let logSheet: ExcelScript.Worksheet | null = null;
  let logTable: ExcelScript.Table | null = null;
  
  if (ENABLE_LOGGING) {
    try {
      // Remove existing log sheet if it exists
      try {
        const oldLogSheet = workbook.getWorksheet("Script_Logs");
        oldLogSheet.delete();
      } catch (e) { /* Sheet doesn't exist */ }
      
      // Create new log sheet
      logSheet = workbook.addWorksheet("Script_Logs");
      logSheet.getRange("A1:E1").setValues([["Timestamp", "Row_ID", "RITM", "Action", "Details"]]);
      logTable = logSheet.addTable("A1:E1", true);
      logTable.setName("ScriptLogs");
      
      console.log("üìã Log sheet created: 'Script_Logs'");
    } catch (error) {
      console.log("‚ö†Ô∏è Could not create log sheet. Continuing without logs.");
    }
  }
  
  function addLog(rowId: string, ritm: string, action: string, details: string) {
    if (!ENABLE_LOGGING || !logTable) return;
    
    try {
      const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
      logTable.addRow(-1, [timestamp, rowId, ritm, action, details]);
    } catch (e) {
      // Silent fail for logging errors
    }
  }
  
  // ====================
  // 3. INITIALIZATION
  // ====================
  console.log("üöÄ Starting Enhanced Bin Automation");
  
  // Load all worksheets and tables
  const sourceSheet = workbook.getWorksheet(SOURCE_SHEET);
  const binSheet = workbook.getWorksheet(BIN_SHEET);
  const outputSheet = workbook.getWorksheet(OUTPUT_SHEET);
  
  if (!sourceSheet || !binSheet) {
    console.log("‚ùå Source or Bin sheet not found");
    return;
  }
  
  const sourceTable = sourceSheet.getTable(SOURCE_TABLE);
  const binTable = binSheet.getTable(BIN_TABLE);
  
  if (!sourceTable || !binTable) {
    console.log("‚ùå Source or Bin table not found");
    return;
  }
  
  // ====================
  // 4. FIND COLUMN INDICES (CRITICAL FIX #1)
  // ====================
  const sourceHeaders = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const sourceRange = sourceTable.getRangeBetweenHeaderAndTotal();
  const sourceData = sourceRange.getValues() as (string | number | boolean)[][];
  const totalSourceRows = sourceData.length;
  
  console.log(`üìä Processing ${totalSourceRows} rows from source`);
  
  // Find all required column indices
  const idColIndex = sourceHeaders.indexOf("Id");
  const ritmColIndex = sourceHeaders.findIndex(h => /^RITM/i.test(h));
  const cmdbStatusColIndex = sourceHeaders.indexOf("CMDB Status");
  
  // Validate critical columns
  if (idColIndex === -1) {
    console.log("‚ùå 'Id' column not found in source table");
    return;
  }
  
  // Log column findings
  if (ritmColIndex === -1) console.log("‚ö†Ô∏è No RITM column found - Rules 1 & 2 will be skipped");
  if (cmdbStatusColIndex === -1) console.log("‚ö†Ô∏è No CMDB Status column found - Rule 3 will be skipped");
  
  // ====================
  // 5. PREPARE OUTPUT SHEET (CRITICAL FIX #2)
  // ====================
  let outputTable: ExcelScript.Table | undefined;
  let outputIdColIndex = -1;
  let outputCmdbColIndex = -1;
  let outputIdToRowMap: Map<string, number> | null = null; // For fast ID lookup
  
  if (outputSheet) {
    try {
      outputTable = outputSheet.getTable(OUTPUT_TABLE);
      if (outputTable) {
        const outputHeaders = outputTable.getHeaderRowRange().getValues()[0] as string[];
        outputIdColIndex = outputHeaders.indexOf("Id");
        outputCmdbColIndex = outputHeaders.indexOf("CMDB Status");
        
        // Build ID-to-row map for fast lookups (CRITICAL FIX)
        if (outputIdColIndex !== -1) {
          const outputRange = outputTable.getRangeBetweenHeaderAndTotal();
          const outputData = outputRange.getValues() as (string | number | boolean)[][];
          outputIdToRowMap = new Map();
          
          for (let j = 0; j < outputData.length; j++) {
            const outputId = outputData[j][outputIdColIndex];
            if (outputId != null) {
              const idStr = String(outputId).trim();
              if (idStr !== "") {
                outputIdToRowMap.set(idStr, j);
              }
            }
          }
          console.log(`üìã Output sheet: Loaded ${outputIdToRowMap.size} IDs for fast lookup`);
        }
      }
    } catch (e) {
      console.log("‚ö†Ô∏è Output table not accessible. Will only update source sheet.");
    }
  } else {
    console.log("‚ÑπÔ∏è Output sheet not found. Will only update source sheet.");
  }
  
  // ====================
  // 6. EXISTING BIN IDs (Avoid Duplicates)
  // ====================
  const binRange = binTable.getRangeBetweenHeaderAndTotal();
  const binData = binRange.getValues() as (string | number | boolean)[][];
  const binHeaders = binTable.getHeaderRowRange().getValues()[0] as string[];
  const binIdColIndex = binHeaders.indexOf("Id");
  const existingBinIds = new Set<string>();
  
  if (binIdColIndex !== -1) {
    for (const row of binData) {
      const id = row[binIdColIndex];
      if (id != null && String(id).trim() !== "") {
        existingBinIds.add(String(id).trim());
      }
    }
  }
  
  // ====================
  // 7. IDENTIFY ROWS TO MOVE (Three Rules)
  // ====================
  const rowsMarkedForBin = new Set<number>();
  const rowReasons: { [key: number]: string } = {};
  const rowStatuses: { [key: number]: string } = {};
  
  // RULE 1: Duplicate RITMs (Keep newest/highest ID)
  if (ritmColIndex !== -1) {
    const ritmGroups: { [key: string]: { rowIndex: number, id: number }[] } = {};
    
    for (let i = 0; i < sourceData.length; i++) {
      const ritmValue = sourceData[i][ritmColIndex];
      const idValue = sourceData[i][idColIndex];
      
      if (ritmValue && String(ritmValue).trim() !== "" && idValue != null) {
        const ritmKey = String(ritmValue).trim().toUpperCase();
        const idNum = Number(idValue);
        
        if (!isNaN(idNum)) {
          if (!ritmGroups[ritmKey]) ritmGroups[ritmKey] = [];
          ritmGroups[ritmKey].push({ rowIndex: i, id: idNum });
        }
      }
    }
    
    // Process duplicate groups
    for (const ritmKey in ritmGroups) {
      const entries = ritmGroups[ritmKey];
      if (entries.length > 1) {
        entries.sort((a, b) => a.id - b.id);
        const keeper = entries[entries.length - 1];
        
        for (const entry of entries) {
          if (entry.rowIndex !== keeper.rowIndex) {
            rowsMarkedForBin.add(entry.rowIndex);
            rowReasons[entry.rowIndex] = `Duplicate RITM '${ritmKey}'`;
            const idValue = sourceData[entry.rowIndex][idColIndex];
            addLog(String(idValue), ritmKey, "MARK_DUPLICATE", `Older duplicate of ID ${keeper.id}`);
          }
        }
      }
    }
  }
  
  // RULE 2: Empty RITM Cells
  if (ritmColIndex !== -1) {
    for (let i = 0; i < sourceData.length; i++) {
      if (rowsMarkedForBin.has(i)) continue;
      
      const ritmValue = sourceData[i][ritmColIndex];
      if (ritmValue == null || String(ritmValue).trim() === "") {
        rowsMarkedForBin.add(i);
        rowReasons[i] = "Empty RITM";
        const idValue = sourceData[i][idColIndex];
        addLog(String(idValue), "", "MARK_EMPTY_RITM", "RITM cell is empty");
      }
    }
  }
  
  // RULE 3: Specific CMDB Status Values
  if (cmdbStatusColIndex !== -1) {
    for (let i = 0; i < sourceData.length; i++) {
      if (rowsMarkedForBin.has(i)) continue;
      
      const statusValue = sourceData[i][cmdbStatusColIndex];
      if (statusValue != null) {
        const statusStr = String(statusValue).toLowerCase().trim();
        if (STATUS_VALUES_TO_BIN.some(badStatus => statusStr === badStatus.toLowerCase())) {
          rowsMarkedForBin.add(i);
          rowReasons[i] = `CMDB Status: '${statusValue}'`;
          rowStatuses[i] = String(statusValue); // Store original status
          const idValue = sourceData[i][idColIndex];
          addLog(String(idValue), "", "MARK_STATUS", `Status: ${statusValue}`);
        }
      }
    }
  }
  
  console.log(`‚úÖ Analysis complete: ${rowsMarkedForBin.size} rows to process`);
  
  // ====================
  // 8. UPDATE CMDB STATUS & MOVE TO BIN (CRITICAL FIX #3-7)
  // ====================
  const rowsToProcess = Array.from(rowsMarkedForBin).sort((a, b) => b - a);
  let movedCount = 0;
  let skippedCount = 0;
  let sourceUpdatedCount = 0;
  let outputUpdatedCount = 0;
  
  // Track which rows we've updated for final deletion
  const rowsToDelete: number[] = [];
  
  for (const sourceRowIndex of rowsToProcess) {
    const sourceRow = sourceData[sourceRowIndex];
    const rowId = sourceRow[idColIndex];
    const rowIdStr = rowId != null ? String(rowId).trim() : "";
    const ritmValue = ritmColIndex !== -1 ? sourceRow[ritmColIndex] : "";
    const ritmStr = ritmValue != null ? String(ritmValue).trim() : "";
    
    // Skip if no ID or already in bin
    if (rowIdStr === "") {
      addLog("", ritmStr, "SKIP_NO_ID", "Row has no ID - skipping");
      skippedCount++;
      continue;
    }
    
    if (existingBinIds.has(rowIdStr)) {
      addLog(rowIdStr, ritmStr, "SKIP_DUPLICATE_ID", "ID already exists in bin");
      skippedCount++;
      continue;
    }
    
    // Determine what the new status should be
    let newStatus: string = "";
    let updateSource = false;
    let updateOutput = false;
    
    if (cmdbStatusColIndex !== -1) {
      const currentStatus = sourceRow[cmdbStatusColIndex];
      const statusStr = currentStatus != null ? String(currentStatus).trim() : "";
      
      // CRITICAL FIX #3: Empty cells should be updated to "bin-duplicate"
      const shouldUpdate = !PRESERVE_STATUSES.some(preserve => 
        statusStr.toLowerCase() === preserve.toLowerCase());
      
      if (shouldUpdate) {
        newStatus = "bin-duplicate";
        updateSource = true;
        updateOutput = true;
      } else {
        newStatus = statusStr; // Keep original preserved status
        // Still update output sheet to sync the preserved status
        updateOutput = (outputIdToRowMap?.has(rowIdStr) ?? false);
      }
    }
    
    // STEP 1: Update Source Sheet (if needed)
    if (updateSource && cmdbStatusColIndex !== -1) {
      const sourceStatusCell = sourceRange.getCell(sourceRowIndex, cmdbStatusColIndex);
      sourceStatusCell.setValue(newStatus);
      
      // CRITICAL FIX #4: Update the in-memory array too
      sourceRow[cmdbStatusColIndex] = newStatus;
      
      sourceUpdatedCount++;
      addLog(rowIdStr, ritmStr, "UPDATE_SOURCE", `Set status to '${newStatus}'`);
    }
    
    // STEP 2: Update Output Sheet (if needed and exists)
    if (updateOutput && outputTable && outputIdToRowMap && outputCmdbColIndex !== -1) {
      const outputRowIndex = outputIdToRowMap.get(rowIdStr);
      
      if (outputRowIndex !== undefined) {
        const outputRange = outputTable.getRangeBetweenHeaderAndTotal();
        const outputStatusCell = outputRange.getCell(outputRowIndex, outputCmdbColIndex);
        outputStatusCell.setValue(newStatus);
        
        outputUpdatedCount++;
        addLog(rowIdStr, ritmStr, "UPDATE_OUTPUT", `Set status to '${newStatus}'`);
      } else {
        addLog(rowIdStr, ritmStr, "OUTPUT_NOT_FOUND", "ID not found in output sheet");
      }
    }
    
    // STEP 3: Move to Bin table (with updated data)
    const newBinRow: (string | number | boolean)[] = [];
    for (const binHeader of binHeaders) {
      const sourceColIndex = sourceHeaders.indexOf(binHeader);
      newBinRow.push(sourceColIndex !== -1 ? sourceRow[sourceColIndex] : "");
    }
    
    binTable.addRow(-1, newBinRow);
    existingBinIds.add(rowIdStr);
    movedCount++;
    rowsToDelete.push(sourceRowIndex);
    
    // STEP 4: Apply strikethrough in Bin
    try {
      const newBinRange = binTable.getRangeBetweenHeaderAndTotal();
      const lastRowIndex = newBinRange.getRowCount() - 1;
      if (lastRowIndex >= 0) {
        const lastRow = newBinRange.getRow(lastRowIndex);
        lastRow.getFormat().getFont().setStrikethrough(true);
      }
    } catch (e) {
      // Silent fail on formatting
    }
    
    addLog(rowIdStr, ritmStr, "MOVED_TO_BIN", `Reason: ${rowReasons[sourceRowIndex]}`);
  }
  
  // ====================
  // 9. DELETE FROM SOURCE (CRITICAL FIX #5)
  // ====================
  if (rowsToDelete.length > 0) {
    // Delete from bottom to top to maintain correct indices
    rowsToDelete.sort((a, b) => b - a);
    
    // Refresh range after potential modifications
    const updatedSourceRange = sourceTable.getRangeBetweenHeaderAndTotal();
    const currentRowCount = updatedSourceRange.getRowCount();
    
    for (const sourceRowIndex of rowsToDelete) {
      if (sourceRowIndex < currentRowCount) {
        updatedSourceRange.getRow(sourceRowIndex).delete(ExcelScript.DeleteShiftDirection.up);
      }
    }
    
    console.log(`üóëÔ∏è  Deleted ${Math.min(rowsToDelete.length, currentRowCount)} rows from source`);
  }
  
  // ====================
  // 10. FINAL SUMMARY
  // ====================
  console.log("=".repeat(50));
  console.log("üèÅ SCRIPT EXECUTION COMPLETE");
  console.log("=".repeat(50));
  console.log(`Total Rows Processed: ${totalSourceRows}`);
  console.log(`Rows Moved to Bin: ${movedCount}`);
  console.log(`Rows Skipped: ${skippedCount} (duplicate IDs or empty)`);
  console.log(`Source Sheet Updates: ${sourceUpdatedCount}`);
  console.log(`Output Sheet Updates: ${outputUpdatedCount}`);
  console.log("");
  
  if (ENABLE_LOGGING) {
    console.log("üìã Detailed logs available in 'Script_Logs' sheet");
    console.log("   To disable logging for production, comment out line 22:");
    console.log("   // const ENABLE_LOGGING = true;");
  }
  
  console.log("=".repeat(50));
}
