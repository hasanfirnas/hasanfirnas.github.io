/**
 * This Office Script processes a table containing RITM data.
 * It finds all unique RITM numbers and returns a JSON structure
 * containing ID and CMDB Status information for each occurrence.
 */

// Define interfaces for our data structures
interface RitmEntry {
  Id: string;
  CMDB_Status: string;
}

interface RitmData {
  [key: string]: RitmEntry[];
}

interface ProcessingResult {
  summary: {
    total_unique_ritms: number;
    total_source_rows: number;
  };
  data: RitmData;
}

function main(workbook: ExcelScript.Workbook): string {
  // ====================
  // 1. GET SOURCE TABLE
  // ====================
  const sourceSheet = workbook.getActiveWorksheet();
  const tables: ExcelScript.Table[] = sourceSheet.getTables();
  
  if (tables.length === 0) {
    return JSON.stringify({ error: "No table found on active worksheet" }, null, 2);
  }
  
  const sourceTable: ExcelScript.Table = tables[0];
  
  // ====================
  // 2. FIND COLUMN INDICES
  // ====================
  const sourceHeaders: string[] = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const sourceRange: ExcelScript.Range = sourceTable.getRangeBetweenHeaderAndTotal();
  const sourceData: (string | number | boolean)[][] = sourceRange.getValues() as (string | number | boolean)[][];
  const totalSourceRows: number = sourceData.length;
  
  // Find all required column indices
  const idColIndex: number = sourceHeaders.indexOf("Id");
  const ritmColIndex: number = sourceHeaders.findIndex(h => /^RITM/i.test(h));
  const cmdbStatusColIndex: number = sourceHeaders.indexOf("CMDB Status");
  
  // Validate critical columns
  if (idColIndex === -1) {
    return JSON.stringify({ error: "'Id' column not found in source table" }, null, 2);
  }
  
  if (ritmColIndex === -1) {
    return JSON.stringify({ error: "No RITM column found in source table" }, null, 2);
  }
  
  // ====================
  // 3. COLLECT DATA BY RITM NUMBER
  // ====================
  const ritmDataMap: RitmData = {};
  
  // Process each row
  for (let i = 0; i < totalSourceRows; i++) {
    const row: (string | number | boolean)[] = sourceData[i];
    const ritmValue: string | number | boolean = row[ritmColIndex];
    
    // Skip rows without RITM value
    if (!ritmValue) continue;
    
    const ritmString: string = ritmValue.toString().trim();
    
    // Create entry object
    const entry: RitmEntry = {
      Id: (row[idColIndex] ? row[idColIndex].toString() : ""),
      CMDB_Status: (cmdbStatusColIndex !== -1 && row[cmdbStatusColIndex]) ? 
                    row[cmdbStatusColIndex].toString() : "N/A"
    };
    
    // Group by RITM number
    if (!ritmDataMap[ritmString]) {
      ritmDataMap[ritmString] = [];
    }
    
    ritmDataMap[ritmString].push(entry);
  }
  
  // ====================
  // 4. REMOVE DUPLICATES WITHIN EACH RITM GROUP
  // ====================
  const uniqueRitmDataMap: RitmData = {};
  
  const ritmNumbers: string[] = Object.keys(ritmDataMap);
  
  ritmNumbers.forEach(ritmNumber => {
    const entries: RitmEntry[] = ritmDataMap[ritmNumber];
    
    // Use a Set to track unique ID-CMDB_Status combinations
    const seen: Set<string> = new Set<string>();
    const uniqueEntries: RitmEntry[] = [];
    
    entries.forEach(entry => {
      const key: string = `${entry.Id}|${entry.CMDB_Status}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueEntries.push(entry);
      }
    });
    
    uniqueRitmDataMap[ritmNumber] = uniqueEntries;
  });
  
  // ====================
  // 5. CREATE FINAL JSON STRUCTURE
  // ====================
  const result: ProcessingResult = {
    summary: {
      total_unique_ritms: Object.keys(uniqueRitmDataMap).length,
      total_source_rows: totalSourceRows
    },
    data: uniqueRitmDataMap
  };
  
  // ====================
  // 6. RETURN THE FULL JSON
  // ====================
  return JSON.stringify(result, null, 2);
}
