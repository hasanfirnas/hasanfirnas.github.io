/**
 * This Office Script processes a table containing RITM data.
 * It finds all unique RITM numbers and returns a JSON structure
 * containing ID and CMDB Status information for each occurrence.
 */

// Define interfaces for our data structures
interface RitmEntry {
  Id: string;
  CMDB_Status: string;
}

interface RitmData {
  [key: string]: RitmEntry[];
}

interface ProcessingResult {
  summary: {
    total_unique_ritms: number;
    total_source_rows: number;
  };
  data: RitmData;
}

function main(workbook: ExcelScript.Workbook): string {
  // ====================
  // 1. GET SOURCE TABLE
  // ====================
  const sourceSheet = workbook.getActiveWorksheet();
  const tables: ExcelScript.Table[] = sourceSheet.getTables();
  
  if (tables.length === 0) {
    console.log("‚ùå No table found on the active worksheet");
    return JSON.stringify({ error: "No table found on active worksheet" });
  }
  
  const sourceTable: ExcelScript.Table = tables[0];
  console.log(`üìä Processing table: ${sourceTable.getName()}`);
  
  // ====================
  // 2. FIND COLUMN INDICES
  // ====================
  const sourceHeaders: string[] = sourceTable.getHeaderRowRange().getValues()[0] as string[];
  const sourceRange: ExcelScript.Range = sourceTable.getRangeBetweenHeaderAndTotal();
  const sourceData: (string | number | boolean)[][] = sourceRange.getValues() as (string | number | boolean)[][];
  const totalSourceRows: number = sourceData.length;
  
  console.log(`üìä Processing ${totalSourceRows} rows from source table`);
  
  // Find all required column indices
  const idColIndex: number = sourceHeaders.indexOf("Id");
  const ritmColIndex: number = sourceHeaders.findIndex(h => /^RITM/i.test(h));
  const cmdbStatusColIndex: number = sourceHeaders.indexOf("CMDB Status");
  
  // Validate critical columns
  if (idColIndex === -1) {
    console.log("‚ùå 'Id' column not found in source table");
    return JSON.stringify({ error: "'Id' column not found in source table" });
  }
  
  if (ritmColIndex === -1) {
    console.log("‚ùå No RITM column found");
    return JSON.stringify({ error: "No RITM column found in source table" });
  }
  
  if (cmdbStatusColIndex === -1) {
    console.log("‚ö†Ô∏è No CMDB Status column found - will use empty values");
  }
  
  console.log(`üìç Column indices - ID: ${idColIndex}, RITM: ${ritmColIndex}, CMDB Status: ${cmdbStatusColIndex}`);
  
  // ====================
  // 3. COLLECT DATA BY RITM NUMBER
  // ====================
  const ritmDataMap: RitmData = {};
  
  // Process each row
  for (let i = 0; i < totalSourceRows; i++) {
    const row: (string | number | boolean)[] = sourceData[i];
    const ritmValue: string | number | boolean = row[ritmColIndex];
    
    // Skip rows without RITM value
    if (!ritmValue) continue;
    
    const ritmString: string = ritmValue.toString().trim();
    
    // Create entry object
    const entry: RitmEntry = {
      Id: (row[idColIndex] ? row[idColIndex].toString() : ""),
      CMDB_Status: (cmdbStatusColIndex !== -1 && row[cmdbStatusColIndex]) ? row[cmdbStatusColIndex].toString() : "N/A"
    };
    
    // Group by RITM number
    if (!ritmDataMap[ritmString]) {
      ritmDataMap[ritmString] = [];
    }
    
    ritmDataMap[ritmString].push(entry);
  }
  
  // ====================
  // 4. REMOVE DUPLICATES WITHIN EACH RITM GROUP
  // ====================
  const uniqueRitmDataMap: RitmData = {};
  
  const ritmNumbers: string[] = Object.keys(ritmDataMap);
  ritmNumbers.forEach(ritmNumber => {
    const entries: RitmEntry[] = ritmDataMap[ritmNumber];
    
    // Use a Set to track unique ID-CMDB_Status combinations
    const seen: Set<string> = new Set<string>();
    const uniqueEntries: RitmEntry[] = [];
    
    entries.forEach(entry => {
      const key: string = `${entry.Id}|${entry.CMDB_Status}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueEntries.push(entry);
      }
    });
    
    uniqueRitmDataMap[ritmNumber] = uniqueEntries;
    
    if (entries.length !== uniqueEntries.length) {
      console.log(`üîÑ RITM ${ritmNumber}: Removed ${entries.length - uniqueEntries.length} duplicate entries`);
    }
  });
  
  // ====================
  // 5. CREATE FINAL JSON STRUCTURE
  // ====================
  const result: ProcessingResult = {
    summary: {
      total_unique_ritms: Object.keys(uniqueRitmDataMap).length,
      total_source_rows: totalSourceRows
    },
    data: uniqueRitmDataMap
  };
  
  // ====================
  // 6. OUTPUT RESULTS
  // ====================
  const jsonOutput: string = JSON.stringify(result, null, 2);
  console.log(`‚úÖ Processing complete. Found ${Object.keys(uniqueRitmDataMap).length} unique RITM numbers.`);
  console.log("üìã JSON output generated successfully.");
  
  // Also log a sample for verification
  const sampleRitms: string[] = ritmNumbers.slice(0, 3);
  sampleRitms.forEach(ritm => {
    console.log(`   Sample - RITM ${ritm}: ${uniqueRitmDataMap[ritm].length} entries`);
  });
  
  return jsonOutput;
}

// Optional: Helper function to process a specific RITM number
/**
 * This function searches for a specific RITM number and returns matching entries.
 * Can be used if you want to query individual RITMs.
 */
function findRitmEntries(workbook: ExcelScript.Workbook, ritmToFind: string): string {
  const mainResult: string = main(workbook);
  
  try {
    const parsedResult: ProcessingResult = JSON.parse(mainResult) as ProcessingResult;
    
    const specificResult = {
      ritm_requested: ritmToFind,
      found: ritmToFind in parsedResult.data,
      entries: parsedResult.data[ritmToFind] || []
    };
    
    return JSON.stringify(specificResult, null, 2);
  } catch (error) {
    return mainResult; // Return the original error if parsing fails
  }
}
